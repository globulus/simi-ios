//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: src/Parser.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collections.h"
#include "java/util/List.h"
#include "Constants.h"
#include "ErrorHub.h"
#include "Expr.h"
#include "Native.h"
#include "Parser.h"
#include "Pass.h"
#include "SimiValue.h"
#include "Stmt.h"
#include "Token.h"
#include "TokenType.h"

@class SMParser_ParseError;

@interface SMParser () {
 @public
  id<JavaUtilList> tokens_;
  jint current_;
  id<JavaUtilList> annotations_;
}

- (SMExpr *)expression;

- (SMStmt *)declaration;

- (SMStmt_Class *)classDeclaration;

- (SMStmt_Annotation *)annotation;

- (SMStmt *)statementWithBoolean:(jboolean)lambda;

- (SMStmt *)forStatement;

- (SMStmt *)ifStatement;

- (SMStmt *)whenStatement;

- (SMStmt *)printStatementWithBoolean:(jboolean)lambda;

- (SMStmt *)returnStatementWithBoolean:(jboolean)lambda;

- (SMStmt *)yieldStatementWithBoolean:(jboolean)lambda;

- (SMStmt *)whileStatement;

- (SMStmt *)breakStatement;

- (SMStmt *)continueStatement;

- (SMStmt *)rescueStatement;

- (SMStmt_Expression *)expressionStatementWithBoolean:(jboolean)lambda;

- (void)checkStatementEndWithBoolean:(jboolean)lambda;

- (SMStmt_Function *)functionWithNSString:(NSString *)kind;

- (SMExpr_Block *)blockWithNSString:(NSString *)kind
                        withBoolean:(jboolean)lambda;

- (SMExpr_Block *)blockWithSMToken:(SMToken *)declaration
                      withNSString:(NSString *)kind
                       withBoolean:(jboolean)lambda
                       withBoolean:(jboolean)addParamChecks;

- (id<JavaUtilList>)getBlockStatementsWithSMToken:(SMToken *)declaration
                                     withNSString:(NSString *)kind;

- (id<JavaUtilList>)paramsWithNSString:(NSString *)kind
                           withBoolean:(jboolean)lambda;

- (JavaLangInteger *)peekParams;

- (SMExpr *)assignment;

- (SMExpr *)or__;

- (SMExpr *)and__;

- (SMExpr *)equality;

- (SMExpr *)comparison;

- (SMExpr *)addition;

- (SMExpr *)multiplication;

- (SMExpr *)nilCoalescence;

- (SMExpr *)unary;

- (SMExpr *)call;

- (SMExpr *)finishCallWithSMExpr:(SMExpr *)callee;

- (SMExpr *)primary;

- (SMExpr *)objectLiteral;

- (void)matchAllNewlines;

- (jboolean)matchSequenceWithSMTokenTypeArray:(IOSObjectArray *)types;

- (jboolean)matchWithSMTokenTypeArray:(IOSObjectArray *)types;

- (SMToken *)consumeWithSMTokenType:(SMTokenType *)type
                       withNSString:(NSString *)message;

- (jboolean)checkWithSMTokenType:(SMTokenType *)tokenType;

- (SMToken *)advance;

- (jboolean)isAtEnd;

- (SMToken *)peek;

- (jboolean)peekSequenceWithSMTokenTypeArray:(IOSObjectArray *)tokenTypes;

- (SMToken *)previous;

- (SMToken *)operatorFromAssignWithSMToken:(SMToken *)assignOp;

- (SMParser_ParseError *)errorWithSMToken:(SMToken *)token
                             withNSString:(NSString *)message;

- (void)synchronize;

- (id<JavaUtilList>)getAnnotations;

- (void)addParamChecksWithSMToken:(SMToken *)declaration
                 withJavaUtilList:(id<JavaUtilList>)params
                 withJavaUtilList:(id<JavaUtilList>)stmts;

@end

J2OBJC_FIELD_SETTER(SMParser, tokens_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(SMParser, annotations_, id<JavaUtilList>)

inline NSString *SMParser_get_LAMBDA(void);
static NSString *SMParser_LAMBDA = @"lambda";
J2OBJC_STATIC_FIELD_OBJ_FINAL(SMParser, LAMBDA, NSString *)

inline NSString *SMParser_get_FUNCTION(void);
static NSString *SMParser_FUNCTION = @"function";
J2OBJC_STATIC_FIELD_OBJ_FINAL(SMParser, FUNCTION, NSString *)

inline NSString *SMParser_get_METHOD(void);
static NSString *SMParser_METHOD = @"method";
J2OBJC_STATIC_FIELD_OBJ_FINAL(SMParser, METHOD, NSString *)

__attribute__((unused)) static SMExpr *SMParser_expression(SMParser *self);

__attribute__((unused)) static SMStmt *SMParser_declaration(SMParser *self);

__attribute__((unused)) static SMStmt_Class *SMParser_classDeclaration(SMParser *self);

__attribute__((unused)) static SMStmt_Annotation *SMParser_annotation(SMParser *self);

__attribute__((unused)) static SMStmt *SMParser_statementWithBoolean_(SMParser *self, jboolean lambda);

__attribute__((unused)) static SMStmt *SMParser_forStatement(SMParser *self);

__attribute__((unused)) static SMStmt *SMParser_ifStatement(SMParser *self);

__attribute__((unused)) static SMStmt *SMParser_whenStatement(SMParser *self);

__attribute__((unused)) static SMStmt *SMParser_printStatementWithBoolean_(SMParser *self, jboolean lambda);

__attribute__((unused)) static SMStmt *SMParser_returnStatementWithBoolean_(SMParser *self, jboolean lambda);

__attribute__((unused)) static SMStmt *SMParser_yieldStatementWithBoolean_(SMParser *self, jboolean lambda);

__attribute__((unused)) static SMStmt *SMParser_whileStatement(SMParser *self);

__attribute__((unused)) static SMStmt *SMParser_breakStatement(SMParser *self);

__attribute__((unused)) static SMStmt *SMParser_continueStatement(SMParser *self);

__attribute__((unused)) static SMStmt *SMParser_rescueStatement(SMParser *self);

__attribute__((unused)) static SMStmt_Expression *SMParser_expressionStatementWithBoolean_(SMParser *self, jboolean lambda);

__attribute__((unused)) static void SMParser_checkStatementEndWithBoolean_(SMParser *self, jboolean lambda);

__attribute__((unused)) static SMStmt_Function *SMParser_functionWithNSString_(SMParser *self, NSString *kind);

__attribute__((unused)) static SMExpr_Block *SMParser_blockWithNSString_withBoolean_(SMParser *self, NSString *kind, jboolean lambda);

__attribute__((unused)) static SMExpr_Block *SMParser_blockWithSMToken_withNSString_withBoolean_withBoolean_(SMParser *self, SMToken *declaration, NSString *kind, jboolean lambda, jboolean addParamChecks);

__attribute__((unused)) static id<JavaUtilList> SMParser_getBlockStatementsWithSMToken_withNSString_(SMParser *self, SMToken *declaration, NSString *kind);

__attribute__((unused)) static id<JavaUtilList> SMParser_paramsWithNSString_withBoolean_(SMParser *self, NSString *kind, jboolean lambda);

__attribute__((unused)) static JavaLangInteger *SMParser_peekParams(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_assignment(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_or__(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_and__(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_equality(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_comparison(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_addition(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_multiplication(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_nilCoalescence(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_unary(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_call(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_finishCallWithSMExpr_(SMParser *self, SMExpr *callee);

__attribute__((unused)) static SMExpr *SMParser_primary(SMParser *self);

__attribute__((unused)) static SMExpr *SMParser_objectLiteral(SMParser *self);

__attribute__((unused)) static void SMParser_matchAllNewlines(SMParser *self);

__attribute__((unused)) static jboolean SMParser_matchSequenceWithSMTokenTypeArray_(SMParser *self, IOSObjectArray *types);

__attribute__((unused)) static jboolean SMParser_matchWithSMTokenTypeArray_(SMParser *self, IOSObjectArray *types);

__attribute__((unused)) static SMToken *SMParser_consumeWithSMTokenType_withNSString_(SMParser *self, SMTokenType *type, NSString *message);

__attribute__((unused)) static jboolean SMParser_checkWithSMTokenType_(SMParser *self, SMTokenType *tokenType);

__attribute__((unused)) static SMToken *SMParser_advance(SMParser *self);

__attribute__((unused)) static jboolean SMParser_isAtEnd(SMParser *self);

__attribute__((unused)) static SMToken *SMParser_peek(SMParser *self);

__attribute__((unused)) static jboolean SMParser_peekSequenceWithSMTokenTypeArray_(SMParser *self, IOSObjectArray *tokenTypes);

__attribute__((unused)) static SMToken *SMParser_previous(SMParser *self);

__attribute__((unused)) static SMToken *SMParser_operatorFromAssignWithSMToken_(SMParser *self, SMToken *assignOp);

__attribute__((unused)) static SMParser_ParseError *SMParser_errorWithSMToken_withNSString_(SMParser *self, SMToken *token, NSString *message);

__attribute__((unused)) static void SMParser_synchronize(SMParser *self);

__attribute__((unused)) static id<JavaUtilList> SMParser_getAnnotations(SMParser *self);

__attribute__((unused)) static void SMParser_addParamChecksWithSMToken_withJavaUtilList_withJavaUtilList_(SMParser *self, SMToken *declaration, id<JavaUtilList> params, id<JavaUtilList> stmts);

@interface SMParser_ParseError : JavaLangRuntimeException

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(SMParser_ParseError)

__attribute__((unused)) static void SMParser_ParseError_init(SMParser_ParseError *self);

__attribute__((unused)) static SMParser_ParseError *new_SMParser_ParseError_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static SMParser_ParseError *create_SMParser_ParseError_init(void);

J2OBJC_TYPE_LITERAL_HEADER(SMParser_ParseError)

@implementation SMParser

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)tokens {
  SMParser_initWithJavaUtilList_(self, tokens);
  return self;
}

- (id<JavaUtilList>)parse {
  id<JavaUtilList> statements = new_JavaUtilArrayList_init();
  while (!SMParser_isAtEnd(self)) {
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IMPORT) } count:1 type:SMTokenType_class_()])) {
      SMToken *keyword = SMParser_previous(self);
      if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IDENTIFIER) } count:1 type:SMTokenType_class_()])) {
        [statements addWithId:new_SMStmt_Import_initWithSMToken_withSMExpr_(keyword, new_SMExpr_Variable_initWithSMToken_(SMParser_previous(self)))];
      }
      else {
        continue;
      }
    }
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NEWLINE), JreLoadEnum(SMTokenType, PASS) } count:2 type:SMTokenType_class_()])) {
      continue;
    }
    [statements addWithId:SMParser_declaration(self)];
  }
  return statements;
}

- (SMExpr *)expression {
  return SMParser_expression(self);
}

- (SMStmt *)declaration {
  return SMParser_declaration(self);
}

- (SMStmt_Class *)classDeclaration {
  return SMParser_classDeclaration(self);
}

- (SMStmt_Annotation *)annotation {
  return SMParser_annotation(self);
}

- (SMStmt *)statementWithBoolean:(jboolean)lambda {
  return SMParser_statementWithBoolean_(self, lambda);
}

- (SMStmt *)forStatement {
  return SMParser_forStatement(self);
}

- (SMStmt *)ifStatement {
  return SMParser_ifStatement(self);
}

- (SMStmt *)whenStatement {
  return SMParser_whenStatement(self);
}

- (SMStmt *)printStatementWithBoolean:(jboolean)lambda {
  return SMParser_printStatementWithBoolean_(self, lambda);
}

- (SMStmt *)returnStatementWithBoolean:(jboolean)lambda {
  return SMParser_returnStatementWithBoolean_(self, lambda);
}

- (SMStmt *)yieldStatementWithBoolean:(jboolean)lambda {
  return SMParser_yieldStatementWithBoolean_(self, lambda);
}

- (SMStmt *)whileStatement {
  return SMParser_whileStatement(self);
}

- (SMStmt *)breakStatement {
  return SMParser_breakStatement(self);
}

- (SMStmt *)continueStatement {
  return SMParser_continueStatement(self);
}

- (SMStmt *)rescueStatement {
  return SMParser_rescueStatement(self);
}

- (SMStmt_Expression *)expressionStatementWithBoolean:(jboolean)lambda {
  return SMParser_expressionStatementWithBoolean_(self, lambda);
}

- (void)checkStatementEndWithBoolean:(jboolean)lambda {
  SMParser_checkStatementEndWithBoolean_(self, lambda);
}

- (SMStmt_Function *)functionWithNSString:(NSString *)kind {
  return SMParser_functionWithNSString_(self, kind);
}

- (SMExpr_Block *)blockWithNSString:(NSString *)kind
                        withBoolean:(jboolean)lambda {
  return SMParser_blockWithNSString_withBoolean_(self, kind, lambda);
}

- (SMExpr_Block *)blockWithSMToken:(SMToken *)declaration
                      withNSString:(NSString *)kind
                       withBoolean:(jboolean)lambda
                       withBoolean:(jboolean)addParamChecks {
  return SMParser_blockWithSMToken_withNSString_withBoolean_withBoolean_(self, declaration, kind, lambda, addParamChecks);
}

- (id<JavaUtilList>)getBlockStatementsWithSMToken:(SMToken *)declaration
                                     withNSString:(NSString *)kind {
  return SMParser_getBlockStatementsWithSMToken_withNSString_(self, declaration, kind);
}

- (id<JavaUtilList>)paramsWithNSString:(NSString *)kind
                           withBoolean:(jboolean)lambda {
  return SMParser_paramsWithNSString_withBoolean_(self, kind, lambda);
}

- (JavaLangInteger *)peekParams {
  return SMParser_peekParams(self);
}

- (SMExpr *)assignment {
  return SMParser_assignment(self);
}

- (SMExpr *)or__ {
  return SMParser_or__(self);
}

- (SMExpr *)and__ {
  return SMParser_and__(self);
}

- (SMExpr *)equality {
  return SMParser_equality(self);
}

- (SMExpr *)comparison {
  return SMParser_comparison(self);
}

- (SMExpr *)addition {
  return SMParser_addition(self);
}

- (SMExpr *)multiplication {
  return SMParser_multiplication(self);
}

- (SMExpr *)nilCoalescence {
  return SMParser_nilCoalescence(self);
}

- (SMExpr *)unary {
  return SMParser_unary(self);
}

- (SMExpr *)call {
  return SMParser_call(self);
}

- (SMExpr *)finishCallWithSMExpr:(SMExpr *)callee {
  return SMParser_finishCallWithSMExpr_(self, callee);
}

- (SMExpr *)primary {
  return SMParser_primary(self);
}

- (SMExpr *)objectLiteral {
  return SMParser_objectLiteral(self);
}

- (void)matchAllNewlines {
  SMParser_matchAllNewlines(self);
}

- (jboolean)matchSequenceWithSMTokenTypeArray:(IOSObjectArray *)types {
  return SMParser_matchSequenceWithSMTokenTypeArray_(self, types);
}

- (jboolean)matchWithSMTokenTypeArray:(IOSObjectArray *)types {
  return SMParser_matchWithSMTokenTypeArray_(self, types);
}

- (SMToken *)consumeWithSMTokenType:(SMTokenType *)type
                       withNSString:(NSString *)message {
  return SMParser_consumeWithSMTokenType_withNSString_(self, type, message);
}

- (jboolean)checkWithSMTokenType:(SMTokenType *)tokenType {
  return SMParser_checkWithSMTokenType_(self, tokenType);
}

- (SMToken *)advance {
  return SMParser_advance(self);
}

- (jboolean)isAtEnd {
  return SMParser_isAtEnd(self);
}

- (SMToken *)peek {
  return SMParser_peek(self);
}

- (jboolean)peekSequenceWithSMTokenTypeArray:(IOSObjectArray *)tokenTypes {
  return SMParser_peekSequenceWithSMTokenTypeArray_(self, tokenTypes);
}

- (SMToken *)previous {
  return SMParser_previous(self);
}

- (SMToken *)operatorFromAssignWithSMToken:(SMToken *)assignOp {
  return SMParser_operatorFromAssignWithSMToken_(self, assignOp);
}

- (SMParser_ParseError *)errorWithSMToken:(SMToken *)token
                             withNSString:(NSString *)message {
  return SMParser_errorWithSMToken_withNSString_(self, token, message);
}

- (void)synchronize {
  SMParser_synchronize(self);
}

- (id<JavaUtilList>)getAnnotations {
  return SMParser_getAnnotations(self);
}

- (void)addParamChecksWithSMToken:(SMToken *)declaration
                 withJavaUtilList:(id<JavaUtilList>)params
                 withJavaUtilList:(id<JavaUtilList>)stmts {
  SMParser_addParamChecksWithSMToken_withJavaUtilList_withJavaUtilList_(self, declaration, params, stmts);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x0, -1, -1, -1, 2, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt_Class;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt_Annotation;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, 3, 4, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, 5, 4, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, 6, 4, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, 7, 4, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMStmt_Expression;", 0x2, 8, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 9, 4, -1, -1, -1, -1 },
    { NULL, "LSMStmt_Function;", 0x2, 10, 11, -1, -1, -1, -1 },
    { NULL, "LSMExpr_Block;", 0x2, 12, 13, -1, -1, -1, -1 },
    { NULL, "LSMExpr_Block;", 0x2, 12, 14, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x2, 15, 16, -1, 17, -1, -1 },
    { NULL, "LJavaUtilList;", 0x2, 18, 13, -1, 19, -1, -1 },
    { NULL, "LJavaLangInteger;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, 20, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, 21, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, 22, 23, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMExpr;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x82, 24, 25, -1, -1, -1, -1 },
    { NULL, "Z", 0x82, 26, 25, -1, -1, -1, -1 },
    { NULL, "LSMToken;", 0x2, 27, 28, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 29, 30, -1, -1, -1, -1 },
    { NULL, "LSMToken;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMToken;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x82, 31, 25, -1, -1, -1, -1 },
    { NULL, "LSMToken;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMToken;", 0x2, 32, 33, -1, -1, -1, -1 },
    { NULL, "LSMParser_ParseError;", 0x2, 34, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0x2, -1, -1, -1, 35, -1, -1 },
    { NULL, "V", 0x2, 36, 37, -1, 38, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaUtilList:);
  methods[1].selector = @selector(parse);
  methods[2].selector = @selector(expression);
  methods[3].selector = @selector(declaration);
  methods[4].selector = @selector(classDeclaration);
  methods[5].selector = @selector(annotation);
  methods[6].selector = @selector(statementWithBoolean:);
  methods[7].selector = @selector(forStatement);
  methods[8].selector = @selector(ifStatement);
  methods[9].selector = @selector(whenStatement);
  methods[10].selector = @selector(printStatementWithBoolean:);
  methods[11].selector = @selector(returnStatementWithBoolean:);
  methods[12].selector = @selector(yieldStatementWithBoolean:);
  methods[13].selector = @selector(whileStatement);
  methods[14].selector = @selector(breakStatement);
  methods[15].selector = @selector(continueStatement);
  methods[16].selector = @selector(rescueStatement);
  methods[17].selector = @selector(expressionStatementWithBoolean:);
  methods[18].selector = @selector(checkStatementEndWithBoolean:);
  methods[19].selector = @selector(functionWithNSString:);
  methods[20].selector = @selector(blockWithNSString:withBoolean:);
  methods[21].selector = @selector(blockWithSMToken:withNSString:withBoolean:withBoolean:);
  methods[22].selector = @selector(getBlockStatementsWithSMToken:withNSString:);
  methods[23].selector = @selector(paramsWithNSString:withBoolean:);
  methods[24].selector = @selector(peekParams);
  methods[25].selector = @selector(assignment);
  methods[26].selector = @selector(or__);
  methods[27].selector = @selector(and__);
  methods[28].selector = @selector(equality);
  methods[29].selector = @selector(comparison);
  methods[30].selector = @selector(addition);
  methods[31].selector = @selector(multiplication);
  methods[32].selector = @selector(nilCoalescence);
  methods[33].selector = @selector(unary);
  methods[34].selector = @selector(call);
  methods[35].selector = @selector(finishCallWithSMExpr:);
  methods[36].selector = @selector(primary);
  methods[37].selector = @selector(objectLiteral);
  methods[38].selector = @selector(matchAllNewlines);
  methods[39].selector = @selector(matchSequenceWithSMTokenTypeArray:);
  methods[40].selector = @selector(matchWithSMTokenTypeArray:);
  methods[41].selector = @selector(consumeWithSMTokenType:withNSString:);
  methods[42].selector = @selector(checkWithSMTokenType:);
  methods[43].selector = @selector(advance);
  methods[44].selector = @selector(isAtEnd);
  methods[45].selector = @selector(peek);
  methods[46].selector = @selector(peekSequenceWithSMTokenTypeArray:);
  methods[47].selector = @selector(previous);
  methods[48].selector = @selector(operatorFromAssignWithSMToken:);
  methods[49].selector = @selector(errorWithSMToken:withNSString:);
  methods[50].selector = @selector(synchronize);
  methods[51].selector = @selector(getAnnotations);
  methods[52].selector = @selector(addParamChecksWithSMToken:withJavaUtilList:withJavaUtilList:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "LAMBDA", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 39, -1, -1 },
    { "FUNCTION", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 40, -1, -1 },
    { "METHOD", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 41, -1, -1 },
    { "tokens_", "LJavaUtilList;", .constantValue.asLong = 0, 0x12, -1, -1, 42, -1 },
    { "current_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "annotations_", "LJavaUtilList;", .constantValue.asLong = 0, 0x2, -1, -1, 43, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilList;", "(Ljava/util/List<LToken;>;)V", "()Ljava/util/List<LStmt;>;", "statement", "Z", "printStatement", "returnStatement", "yieldStatement", "expressionStatement", "checkStatementEnd", "function", "LNSString;", "block", "LNSString;Z", "LSMToken;LNSString;ZZ", "getBlockStatements", "LSMToken;LNSString;", "(LToken;Ljava/lang/String;)Ljava/util/List<LStmt;>;", "params", "(Ljava/lang/String;Z)Ljava/util/List<LExpr;>;", "or", "and", "finishCall", "LSMExpr;", "matchSequence", "[LSMTokenType;", "match", "consume", "LSMTokenType;LNSString;", "check", "LSMTokenType;", "peekSequence", "operatorFromAssign", "LSMToken;", "error", "()Ljava/util/List<LStmt$Annotation;>;", "addParamChecks", "LSMToken;LJavaUtilList;LJavaUtilList;", "(LToken;Ljava/util/List<LExpr;>;Ljava/util/List<LStmt;>;)V", &SMParser_LAMBDA, &SMParser_FUNCTION, &SMParser_METHOD, "Ljava/util/List<LToken;>;", "Ljava/util/List<LStmt$Annotation;>;", "LSMParser_ParseError;" };
  static const J2ObjcClassInfo _SMParser = { "Parser", "net.globulus.simi", ptrTable, methods, fields, 7, 0x0, 53, 6, -1, 44, -1, -1, -1 };
  return &_SMParser;
}

@end

void SMParser_initWithJavaUtilList_(SMParser *self, id<JavaUtilList> tokens) {
  NSObject_init(self);
  self->current_ = 0;
  self->annotations_ = new_JavaUtilArrayList_init();
  self->tokens_ = tokens;
}

SMParser *new_SMParser_initWithJavaUtilList_(id<JavaUtilList> tokens) {
  J2OBJC_NEW_IMPL(SMParser, initWithJavaUtilList_, tokens)
}

SMParser *create_SMParser_initWithJavaUtilList_(id<JavaUtilList> tokens) {
  J2OBJC_CREATE_IMPL(SMParser, initWithJavaUtilList_, tokens)
}

SMExpr *SMParser_expression(SMParser *self) {
  return SMParser_assignment(self);
}

SMStmt *SMParser_declaration(SMParser *self) {
  @try {
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, CLASS), JreLoadEnum(SMTokenType, CLASS_FINAL), JreLoadEnum(SMTokenType, CLASS_OPEN) } count:3 type:SMTokenType_class_()])) {
      return SMParser_classDeclaration(self);
    }
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, DEF) } count:1 type:SMTokenType_class_()])) {
      return SMParser_functionWithNSString_(self, SMParser_FUNCTION);
    }
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, BANG) } count:1 type:SMTokenType_class_()])) {
      return SMParser_annotation(self);
    }
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IMPORT) } count:1 type:SMTokenType_class_()])) {
      SMToken *keyword = SMParser_previous(self);
      if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IDENTIFIER) } count:1 type:SMTokenType_class_()])) {
        return new_SMStmt_Import_initWithSMToken_withSMExpr_(keyword, new_SMExpr_Variable_initWithSMToken_(SMParser_previous(self)));
      }
    }
    return SMParser_statementWithBoolean_(self, false);
  }
  @catch (SMParser_ParseError *error) {
    SMParser_synchronize(self);
    return nil;
  }
}

SMStmt_Class *SMParser_classDeclaration(SMParser *self) {
  SMToken *opener = SMParser_previous(self);
  SMToken *name = SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), @"Expect class name.");
  id<JavaUtilList> superclasses = nil;
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, LEFT_PAREN) } count:1 type:SMTokenType_class_()])) {
    if (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, RIGHT_PAREN))) {
      superclasses = new_JavaUtilArrayList_init();
      do {
        [superclasses addWithId:SMParser_call(self)];
      }
      while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, COMMA) } count:1 type:SMTokenType_class_()]));
    }
    (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, RIGHT_PAREN), @"Expect ')' after superclasses.");
  }
  (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, COLON), @"Expect ':' before class body.");
  id<JavaUtilList> constants = new_JavaUtilArrayList_init();
  id<JavaUtilList> mixins = new_JavaUtilArrayList_init();
  id<JavaUtilList> innerClasses = new_JavaUtilArrayList_init();
  id<JavaUtilList> methods = new_JavaUtilArrayList_init();
  while (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, END)) && !SMParser_isAtEnd(self)) {
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NEWLINE) } count:1 type:SMTokenType_class_()])) {
      continue;
    }
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, DEF) } count:1 type:SMTokenType_class_()])) {
      [methods addWithId:SMParser_functionWithNSString_(self, SMParser_METHOD)];
    }
    else if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, CLASS), JreLoadEnum(SMTokenType, CLASS_FINAL), JreLoadEnum(SMTokenType, CLASS_OPEN) } count:3 type:SMTokenType_class_()])) {
      [innerClasses addWithId:SMParser_classDeclaration(self)];
    }
    else if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IMPORT) } count:1 type:SMTokenType_class_()])) {
      SMExpr *expr = SMParser_call(self);
      if ([expr isKindOfClass:[SMExpr_Get class]] || [expr isKindOfClass:[SMExpr_Variable class]]) {
        [mixins addWithId:expr];
      }
      else {
        (void) SMParser_errorWithSMToken_withNSString_(self, SMParser_previous(self), @"Expected a get or variable expr after mixin import.");
      }
    }
    else if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, BANG) } count:1 type:SMTokenType_class_()])) {
      [((id<JavaUtilList>) nil_chk(self->annotations_)) addWithId:SMParser_annotation(self)];
    }
    else {
      SMExpr *expr = SMParser_assignment(self);
      if ([expr isKindOfClass:[SMExpr_Assign class]]) {
        [constants addWithId:(SMExpr_Assign *) cast_chk(expr, [SMExpr_Assign class])];
      }
    }
  }
  (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, END), @"Expect 'end' after class body.");
  return new_SMStmt_Class_initWithSMToken_withSMToken_withJavaUtilList_withJavaUtilList_withJavaUtilList_withJavaUtilList_withJavaUtilList_withJavaUtilList_(opener, name, superclasses, mixins, constants, innerClasses, methods, SMParser_getAnnotations(self));
}

SMStmt_Annotation *SMParser_annotation(SMParser *self) {
  SMExpr *expr = nil;
  if (((SMToken *) nil_chk(SMParser_peek(self)))->type_ == JreLoadEnum(SMTokenType, LEFT_BRACKET)) {
    (void) SMParser_advance(self);
    expr = SMParser_objectLiteral(self);
  }
  else if (((SMToken *) nil_chk(SMParser_peek(self)))->type_ == JreLoadEnum(SMTokenType, IDENTIFIER)) {
    expr = SMParser_call(self);
  }
  else {
    [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) errorWithSMToken:SMParser_peek(self) withNSString:@"Annotation expect either an object literal or a constructor invocation!"];
  }
  SMParser_checkStatementEndWithBoolean_(self, false);
  return new_SMStmt_Annotation_initWithSMExpr_(expr);
}

SMStmt *SMParser_statementWithBoolean_(SMParser *self, jboolean lambda) {
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, FOR) } count:1 type:SMTokenType_class_()])) {
    return SMParser_forStatement(self);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IF) } count:1 type:SMTokenType_class_()])) {
    return SMParser_ifStatement(self);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, WHEN) } count:1 type:SMTokenType_class_()])) {
    return SMParser_whenStatement(self);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, PRINT) } count:1 type:SMTokenType_class_()])) {
    return SMParser_printStatementWithBoolean_(self, lambda);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, RETURN) } count:1 type:SMTokenType_class_()])) {
    return SMParser_returnStatementWithBoolean_(self, lambda);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, WHILE) } count:1 type:SMTokenType_class_()])) {
    return SMParser_whileStatement(self);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, BREAK) } count:1 type:SMTokenType_class_()])) {
    return SMParser_breakStatement(self);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, CONTINUE) } count:1 type:SMTokenType_class_()])) {
    return SMParser_continueStatement(self);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, RESCUE) } count:1 type:SMTokenType_class_()])) {
    return SMParser_rescueStatement(self);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, YIELD) } count:1 type:SMTokenType_class_()])) {
    return SMParser_yieldStatementWithBoolean_(self, lambda);
  }
  return SMParser_expressionStatementWithBoolean_(self, lambda);
}

SMStmt *SMParser_forStatement(SMParser *self) {
  SMToken *var = SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), @"Expected identifier.");
  (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IN), @"Expected 'in'.");
  SMExpr *iterable = SMParser_expression(self);
  SMExpr_Block *body = SMParser_blockWithNSString_withBoolean_(self, @"for", true);
  return new_SMStmt_For_initWithSMExpr_Variable_withSMExpr_withSMExpr_Block_(new_SMExpr_Variable_initWithSMToken_(var), iterable, body);
}

SMStmt *SMParser_ifStatement(SMParser *self) {
  SMExpr *condition = SMParser_expression(self);
  SMExpr_Block *thenBranch = SMParser_blockWithNSString_withBoolean_(self, @"if", true);
  SMExpr_Block *elseBranch = nil;
  id<JavaUtilList> elsifs = new_JavaUtilArrayList_init();
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, ELSIF), JreLoadEnum(SMTokenType, NEWLINE) } count:2 type:SMTokenType_class_()])) {
    if (((SMToken *) nil_chk(SMParser_previous(self)))->type_ == JreLoadEnum(SMTokenType, ELSIF)) {
      [elsifs addWithId:new_SMStmt_Elsif_initWithSMExpr_withSMExpr_Block_(SMParser_expression(self), SMParser_blockWithNSString_withBoolean_(self, @"elsif", true))];
    }
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, ELSE) } count:1 type:SMTokenType_class_()])) {
    elseBranch = SMParser_blockWithNSString_withBoolean_(self, @"else", true);
  }
  return new_SMStmt_If_initWithSMStmt_Elsif_withJavaUtilList_withSMExpr_Block_(new_SMStmt_Elsif_initWithSMExpr_withSMExpr_Block_(condition, thenBranch), elsifs, elseBranch);
}

SMStmt *SMParser_whenStatement(SMParser *self) {
  SMToken *when = SMParser_previous(self);
  SMExpr *left = SMParser_call(self);
  (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, COLON), @"Expect a ':' after when.");
  (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, NEWLINE), @"Expect a newline after when ':.");
  SMStmt_Elsif *firstElsif = nil;
  id<JavaUtilList> elsifs = new_JavaUtilArrayList_init();
  SMExpr_Block *elseBranch = nil;
  while (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, END)) && !SMParser_isAtEnd(self)) {
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NEWLINE) } count:1 type:SMTokenType_class_()])) {
      continue;
    }
    id<JavaUtilList> conditions = new_JavaUtilArrayList_init();
    do {
      SMToken *op;
      if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IS), JreLoadEnum(SMTokenType, ISNOT), JreLoadEnum(SMTokenType, IN), JreLoadEnum(SMTokenType, NOTIN) } count:4 type:SMTokenType_class_()])) {
        op = SMParser_previous(self);
      }
      else if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, ELSE) } count:1 type:SMTokenType_class_()])) {
        elseBranch = SMParser_blockWithNSString_withBoolean_(self, @"else", true);
        break;
      }
      else {
        op = new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, EQUAL_EQUAL), nil, nil, ((SMToken *) nil_chk(when))->line_);
      }
      SMExpr *right = SMParser_call(self);
      [conditions addWithId:new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(left, op, right)];
      SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, OR) } count:1 type:SMTokenType_class_()]);
    }
    while (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, COLON)));
    if ([conditions isEmpty]) {
      continue;
    }
    SMExpr *condition = [conditions getWithInt:0];
    SMToken *or_ = new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, OR), nil, nil, ((SMToken *) nil_chk(when))->line_);
    for (jint i = 1; i < [conditions size]; i++) {
      condition = new_SMExpr_Logical_initWithSMExpr_withSMToken_withSMExpr_(condition, or_, [conditions getWithInt:i]);
    }
    SMStmt_Elsif *elsif = new_SMStmt_Elsif_initWithSMExpr_withSMExpr_Block_(condition, SMParser_blockWithNSString_withBoolean_(self, @"when", true));
    if (firstElsif == nil) {
      firstElsif = elsif;
    }
    else {
      [elsifs addWithId:elsif];
    }
  }
  (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, END), @"Expect end at the end of when.");
  return new_SMStmt_If_initWithSMStmt_Elsif_withJavaUtilList_withSMExpr_Block_(firstElsif, elsifs, elseBranch);
}

SMStmt *SMParser_printStatementWithBoolean_(SMParser *self, jboolean lambda) {
  SMExpr *value = ((SMStmt_Expression *) nil_chk(SMParser_expressionStatementWithBoolean_(self, lambda)))->expression_;
  return new_SMStmt_Print_initWithSMExpr_(value);
}

SMStmt *SMParser_returnStatementWithBoolean_(SMParser *self, jboolean lambda) {
  SMToken *keyword = SMParser_previous(self);
  SMExpr *value = nil;
  if (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, NEWLINE))) {
    value = SMParser_expression(self);
  }
  SMParser_checkStatementEndWithBoolean_(self, lambda);
  return new_SMStmt_Return_initWithSMToken_withSMExpr_(keyword, value);
}

SMStmt *SMParser_yieldStatementWithBoolean_(SMParser *self, jboolean lambda) {
  SMToken *keyword = SMParser_previous(self);
  SMExpr *value = nil;
  if (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, NEWLINE))) {
    value = SMParser_expression(self);
  }
  SMParser_checkStatementEndWithBoolean_(self, lambda);
  return new_SMStmt_Yield_initWithSMToken_withSMExpr_(keyword, value);
}

SMStmt *SMParser_whileStatement(SMParser *self) {
  SMExpr *condition = SMParser_expression(self);
  SMExpr_Block *block = SMParser_blockWithNSString_withBoolean_(self, @"while", true);
  return new_SMStmt_While_initWithSMExpr_withSMExpr_Block_(condition, block);
}

SMStmt *SMParser_breakStatement(SMParser *self) {
  SMToken *name = SMParser_previous(self);
  return new_SMStmt_Break_initWithSMToken_(name);
}

SMStmt *SMParser_continueStatement(SMParser *self) {
  SMToken *name = SMParser_previous(self);
  return new_SMStmt_Continue_initWithSMToken_(name);
}

SMStmt *SMParser_rescueStatement(SMParser *self) {
  SMToken *keyword = SMParser_previous(self);
  SMExpr_Block *block = SMParser_blockWithNSString_withBoolean_(self, @"rescue", true);
  if ([((id<JavaUtilList>) nil_chk(((SMExpr_Block *) nil_chk(block))->params_)) size] != 1) {
    [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) errorWithSMToken:keyword withNSString:@"Rescue block expects exactly 1 parameter!"];
  }
  return new_SMStmt_Rescue_initWithSMToken_withSMExpr_Block_(keyword, block);
}

SMStmt_Expression *SMParser_expressionStatementWithBoolean_(SMParser *self, jboolean lambda) {
  SMExpr *expr = SMParser_expression(self);
  if (!([expr isKindOfClass:[SMExpr_Assign class]]) || !([((SMExpr_Assign *) nil_chk(((SMExpr_Assign *) cast_chk(expr, [SMExpr_Assign class]))))->value_ isKindOfClass:[SMExpr_Block class]])) {
    SMParser_checkStatementEndWithBoolean_(self, lambda);
  }
  return new_SMStmt_Expression_initWithSMExpr_(expr);
}

void SMParser_checkStatementEndWithBoolean_(SMParser *self, jboolean lambda) {
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NEWLINE), JreLoadEnum(SMTokenType, EOF) } count:2 type:SMTokenType_class_()])) {
    return;
  }
  if (lambda) {
    SMToken *token = SMParser_peek(self);
    if (((SMToken *) nil_chk(token))->type_ == JreLoadEnum(SMTokenType, COMMA) || token->type_ == JreLoadEnum(SMTokenType, RIGHT_PAREN) || token->type_ == JreLoadEnum(SMTokenType, RIGHT_BRACKET)) {
      return;
    }
  }
  (void) SMParser_errorWithSMToken_withNSString_(self, SMParser_peek(self), @"Unterminated lambda expression!");
}

SMStmt_Function *SMParser_functionWithNSString_(SMParser *self, NSString *kind) {
  SMToken *declaration = SMParser_previous(self);
  SMToken *name = SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), JreStrcat("$$$", @"Expect ", kind, @" name."));
  id<JavaUtilList> annotations = SMParser_getAnnotations(self);
  NSString *blockKind = [((NSString *) nil_chk(((SMToken *) nil_chk(name))->lexeme_)) isEqual:SMConstants_INIT] ? SMConstants_INIT : kind;
  SMExpr_Block *block = SMParser_blockWithSMToken_withNSString_withBoolean_withBoolean_(self, declaration, blockKind, false, false);
  id<JavaUtilList> statements;
  if ([name->lexeme_ isEqual:SMConstants_INIT] && [((SMExpr_Block *) nil_chk(block)) isEmpty]) {
    statements = new_JavaUtilArrayList_init();
    for (SMExpr * __strong param in nil_chk(((SMExpr_Block *) nil_chk(block))->params_)) {
      SMExpr_Variable *paramName;
      if ([param isKindOfClass:[SMExpr_Variable class]]) {
        paramName = (SMExpr_Variable *) cast_chk(param, [SMExpr_Variable class]);
      }
      else {
        SMExpr_Binary *typeCheck = (SMExpr_Binary *) cast_chk(param, [SMExpr_Binary class]);
        paramName = (SMExpr_Variable *) cast_chk(((SMExpr_Binary *) nil_chk(typeCheck))->left_, [SMExpr_Variable class]);
      }
      [statements addWithId:new_SMStmt_Expression_initWithSMExpr_(new_SMExpr_Set_initWithSMToken_withSMExpr_withSMExpr_withSMExpr_(name, new_SMExpr_Self_initWithSMToken_withSMToken_(SMToken_self__(), nil), paramName, paramName))];
    }
  }
  else {
    statements = ((SMExpr_Block *) nil_chk(block))->statements_;
  }
  SMParser_addParamChecksWithSMToken_withJavaUtilList_withJavaUtilList_(self, declaration, block->params_, statements);
  block = new_SMExpr_Block_initWithSMToken_withJavaUtilList_withJavaUtilList_withBoolean_(declaration, block->params_, statements, true);
  return new_SMStmt_Function_initWithSMToken_withSMExpr_Block_withJavaUtilList_(name, block, annotations);
}

SMExpr_Block *SMParser_blockWithNSString_withBoolean_(SMParser *self, NSString *kind, jboolean lambda) {
  return SMParser_blockWithSMToken_withNSString_withBoolean_withBoolean_(self, nil, kind, lambda, true);
}

SMExpr_Block *SMParser_blockWithSMToken_withNSString_withBoolean_withBoolean_(SMParser *self, SMToken *declaration, NSString *kind, jboolean lambda, jboolean addParamChecks) {
  if (declaration == nil) {
    declaration = SMParser_previous(self);
  }
  id<JavaUtilList> params = SMParser_paramsWithNSString_withBoolean_(self, kind, lambda);
  (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, COLON), @"Expected a ':' at the start of block!");
  id<JavaUtilList> statements = SMParser_getBlockStatementsWithSMToken_withNSString_(self, declaration, kind);
  if (addParamChecks) {
    SMParser_addParamChecksWithSMToken_withJavaUtilList_withJavaUtilList_(self, declaration, params, statements);
  }
  return new_SMExpr_Block_initWithSMToken_withJavaUtilList_withJavaUtilList_withBoolean_(declaration, params, statements, [((NSString *) nil_chk(kind)) isEqual:SMParser_LAMBDA] || [kind isEqual:SMParser_FUNCTION] || [kind isEqual:SMParser_METHOD]);
}

id<JavaUtilList> SMParser_getBlockStatementsWithSMToken_withNSString_(SMParser *self, SMToken *declaration, NSString *kind) {
  id<JavaUtilList> statements = new_JavaUtilArrayList_init();
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NEWLINE) } count:1 type:SMTokenType_class_()])) {
    while (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, END)) && !SMParser_isAtEnd(self)) {
      if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NEWLINE), JreLoadEnum(SMTokenType, PASS) } count:2 type:SMTokenType_class_()])) {
        continue;
      }
      [statements addWithId:SMParser_declaration(self)];
    }
    (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, END), @"Expect 'end' after block.");
  }
  else {
    SMStmt *stmt = SMParser_statementWithBoolean_(self, true);
    if ([((NSString *) nil_chk(kind)) isEqual:SMParser_LAMBDA] && [stmt isKindOfClass:[SMStmt_Expression class]]) {
      stmt = new_SMStmt_Return_initWithSMToken_withSMExpr_(new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, RETURN), nil, nil, ((SMToken *) nil_chk(declaration))->line_), ((SMStmt_Expression *) nil_chk(((SMStmt_Expression *) cast_chk(stmt, [SMStmt_Expression class]))))->expression_);
    }
    [statements addWithId:stmt];
  }
  return statements;
}

id<JavaUtilList> SMParser_paramsWithNSString_withBoolean_(SMParser *self, NSString *kind, jboolean lambda) {
  id<JavaUtilList> params = new_JavaUtilArrayList_init();
  if (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, LEFT_PAREN))) {
    if (lambda && !SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, COLON))) {
      SMToken *id_ = SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), @"Expect parameter name.");
      [params addWithId:new_SMExpr_Variable_initWithSMToken_(id_)];
    }
  }
  else {
    (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, LEFT_PAREN), JreStrcat("$$$", @"Expect '(' after ", kind, @" name."));
    if (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, RIGHT_PAREN))) {
      do {
        SMExpr_Variable *id_ = new_SMExpr_Variable_initWithSMToken_(SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), @"Expect parameter name."));
        if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IS) } count:1 type:SMTokenType_class_()])) {
          SMToken *is = SMParser_previous(self);
          SMExpr_Variable *type = new_SMExpr_Variable_initWithSMToken_(SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), @"Expected type after is."));
          [params addWithId:new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(id_, is, type)];
        }
        else {
          [params addWithId:id_];
        }
      }
      while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, COMMA) } count:1 type:SMTokenType_class_()]));
    }
    (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, RIGHT_PAREN), @"Expect ')' after parameters.");
  }
  return params;
}

JavaLangInteger *SMParser_peekParams(SMParser *self) {
  if (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, LEFT_PAREN))) {
    return nil;
  }
  if (SMParser_peekSequenceWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, LEFT_PAREN), JreLoadEnum(SMTokenType, RIGHT_PAREN) } count:2 type:SMTokenType_class_()])) {
    return JavaLangInteger_valueOfWithInt_(0);
  }
  jint len = [((id<JavaUtilList>) nil_chk(self->tokens_)) size];
  jint count = 1;
  jint parenCount = 0;
  for (jint i = self->current_ + 1; i < len; i++) {
    SMTokenType *type = ((SMToken *) nil_chk([self->tokens_ getWithInt:i]))->type_;
    if (type == JreLoadEnum(SMTokenType, LEFT_PAREN) || type == JreLoadEnum(SMTokenType, LEFT_BRACKET) || type == JreLoadEnum(SMTokenType, DOLLAR_LEFT_BRACKET)) {
      parenCount++;
    }
    else if (type == JreLoadEnum(SMTokenType, RIGHT_PAREN) || type == JreLoadEnum(SMTokenType, RIGHT_BRACKET)) {
      if (parenCount == 0) {
        break;
      }
      else {
        parenCount--;
      }
    }
    else if (type == JreLoadEnum(SMTokenType, COMMA) && parenCount == 0) {
      count++;
    }
  }
  return JavaLangInteger_valueOfWithInt_(count);
}

SMExpr *SMParser_assignment(SMParser *self) {
  SMExpr *expr = SMParser_or__(self);
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, EQUAL), JreLoadEnum(SMTokenType, PLUS_EQUAL), JreLoadEnum(SMTokenType, MINUS_EQUAL), JreLoadEnum(SMTokenType, STAR_EQUAL), JreLoadEnum(SMTokenType, SLASH_EQUAL), JreLoadEnum(SMTokenType, MOD_EQUAL) } count:6 type:SMTokenType_class_()])) {
    SMToken *equals = SMParser_previous(self);
    SMExpr *value = SMParser_assignment(self);
    if ([expr isKindOfClass:[SMExpr_Literal class]] && [((SMExpr_Literal *) nil_chk(((SMExpr_Literal *) cast_chk(expr, [SMExpr_Literal class]))))->value_ isKindOfClass:[SMSimiValue_String class]]) {
      SMToken *literal = new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, STRING), nil, ((SMExpr_Literal *) nil_chk(((SMExpr_Literal *) cast_chk(expr, [SMExpr_Literal class]))))->value_, ((SMToken *) nil_chk(equals))->line_);
      return new_SMExpr_Assign_initWithSMToken_withSMExpr_withJavaUtilList_(literal, value, SMParser_getAnnotations(self));
    }
    else if ([expr isKindOfClass:[SMExpr_Variable class]]) {
      SMToken *name = ((SMExpr_Variable *) nil_chk(((SMExpr_Variable *) cast_chk(expr, [SMExpr_Variable class]))))->name_;
      if (((SMToken *) nil_chk(equals))->type_ == JreLoadEnum(SMTokenType, EQUAL)) {
        return new_SMExpr_Assign_initWithSMToken_withSMExpr_withJavaUtilList_(name, value, SMParser_getAnnotations(self));
      }
      else {
        return new_SMExpr_Assign_initWithSMToken_withSMExpr_withJavaUtilList_(name, new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(expr, SMParser_operatorFromAssignWithSMToken_(self, equals), value), SMParser_getAnnotations(self));
      }
    }
    else if ([expr isKindOfClass:[SMExpr_Get class]]) {
      if (((SMToken *) nil_chk(equals))->type_ == JreLoadEnum(SMTokenType, EQUAL)) {
        SMExpr_Get *get = (SMExpr_Get *) cast_chk(expr, [SMExpr_Get class]);
        return new_SMExpr_Set_initWithSMToken_withSMExpr_withSMExpr_withSMExpr_(((SMExpr_Get *) nil_chk(get))->origin_, get->object_, get->name_, value);
      }
      else {
        [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) errorWithSMToken:equals withNSString:@"Cannot use compound assignment operators with setters!"];
      }
    }
    else if ([expr isKindOfClass:[SMExpr_ObjectLiteral class]]) {
      SMExpr_ObjectLiteral *objectLiteral = (SMExpr_ObjectLiteral *) cast_chk(expr, [SMExpr_ObjectLiteral class]);
      if (((SMExpr_ObjectLiteral *) nil_chk(objectLiteral))->isDictionary_ || ((SMToken *) nil_chk(objectLiteral->opener_))->type_ == JreLoadEnum(SMTokenType, DOLLAR_LEFT_BRACKET)) {
        [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) errorWithInt:((SMToken *) nil_chk(equals))->line_ withNSString:@"Invalid object decomposition syntax."];
      }
      id<JavaUtilList> assigns = new_JavaUtilArrayList_init();
      id<JavaUtilList> annotations = SMParser_getAnnotations(self);
      for (jint i = 0; i < [((id<JavaUtilList>) nil_chk(objectLiteral->props_)) size]; i++) {
        SMExpr *prop = [objectLiteral->props_ getWithInt:i];
        SMToken *name = ((SMExpr_Variable *) nil_chk(((SMExpr_Variable *) cast_chk(prop, [SMExpr_Variable class]))))->name_;
        SMExpr *getByName = new_SMExpr_Get_initWithSMToken_withSMExpr_withSMExpr_withJavaLangInteger_(name, value, prop, nil);
        SMExpr *getByIndex = new_SMExpr_Get_initWithSMToken_withSMExpr_withSMExpr_withJavaLangInteger_(name, value, new_SMExpr_Literal_initWithSMSimiValue_(new_SMSimiValue_Number_initWithDouble_(i)), nil);
        SMExpr *nilCoalescence = new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(getByName, new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, QUESTION_QUESTION), nil, nil, ((SMToken *) nil_chk(name))->line_), getByIndex);
        [assigns addWithId:new_SMExpr_Assign_initWithSMToken_withSMExpr_withJavaUtilList_(name, nilCoalescence, annotations)];
      }
      return new_SMExpr_ObjectDecomp_initWithJavaUtilList_(assigns);
    }
    [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) errorWithSMToken:equals withNSString:@"Invalid assignment target."];
  }
  return expr;
}

SMExpr *SMParser_or__(SMParser *self) {
  SMExpr *expr = SMParser_and__(self);
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, OR) } count:1 type:SMTokenType_class_()])) {
    SMToken *operator_ = SMParser_previous(self);
    SMExpr *right = SMParser_and__(self);
    expr = new_SMExpr_Logical_initWithSMExpr_withSMToken_withSMExpr_(expr, operator_, right);
  }
  return expr;
}

SMExpr *SMParser_and__(SMParser *self) {
  SMExpr *expr = SMParser_equality(self);
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, AND) } count:1 type:SMTokenType_class_()])) {
    SMToken *operator_ = SMParser_previous(self);
    SMExpr *right = SMParser_equality(self);
    expr = new_SMExpr_Logical_initWithSMExpr_withSMToken_withSMExpr_(expr, operator_, right);
  }
  return expr;
}

SMExpr *SMParser_equality(SMParser *self) {
  SMExpr *expr = SMParser_comparison(self);
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, BANG_EQUAL), JreLoadEnum(SMTokenType, EQUAL_EQUAL), JreLoadEnum(SMTokenType, IS), JreLoadEnum(SMTokenType, ISNOT), JreLoadEnum(SMTokenType, IN), JreLoadEnum(SMTokenType, NOTIN) } count:6 type:SMTokenType_class_()])) {
    SMToken *operator_ = SMParser_previous(self);
    SMExpr *right = SMParser_comparison(self);
    expr = new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(expr, operator_, right);
  }
  return expr;
}

SMExpr *SMParser_comparison(SMParser *self) {
  SMExpr *expr = SMParser_addition(self);
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, GREATER), JreLoadEnum(SMTokenType, GREATER_EQUAL), JreLoadEnum(SMTokenType, LESS), JreLoadEnum(SMTokenType, LESS_EQUAL), JreLoadEnum(SMTokenType, LESS_GREATER) } count:5 type:SMTokenType_class_()])) {
    SMToken *operator_ = SMParser_previous(self);
    SMExpr *right = SMParser_addition(self);
    expr = new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(expr, operator_, right);
  }
  return expr;
}

SMExpr *SMParser_addition(SMParser *self) {
  SMExpr *expr = SMParser_multiplication(self);
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, MINUS), JreLoadEnum(SMTokenType, PLUS) } count:2 type:SMTokenType_class_()])) {
    SMToken *operator_ = SMParser_previous(self);
    SMExpr *right = SMParser_multiplication(self);
    expr = new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(expr, operator_, right);
  }
  return expr;
}

SMExpr *SMParser_multiplication(SMParser *self) {
  SMExpr *expr = SMParser_nilCoalescence(self);
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, SLASH), JreLoadEnum(SMTokenType, SLASH_SLASH), JreLoadEnum(SMTokenType, STAR), JreLoadEnum(SMTokenType, MOD) } count:4 type:SMTokenType_class_()])) {
    SMToken *operator_ = SMParser_previous(self);
    SMExpr *right = SMParser_nilCoalescence(self);
    expr = new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(expr, operator_, right);
  }
  return expr;
}

SMExpr *SMParser_nilCoalescence(SMParser *self) {
  SMExpr *expr = SMParser_unary(self);
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, QUESTION_QUESTION) } count:1 type:SMTokenType_class_()])) {
    SMToken *operator_ = SMParser_previous(self);
    SMExpr *right = SMParser_unary(self);
    expr = new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(expr, operator_, right);
  }
  return expr;
}

SMExpr *SMParser_unary(SMParser *self) {
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NOT), JreLoadEnum(SMTokenType, MINUS) } count:2 type:SMTokenType_class_()])) {
    SMToken *operator_ = SMParser_previous(self);
    SMExpr *right = SMParser_unary(self);
    return new_SMExpr_Unary_initWithSMToken_withSMExpr_(operator_, right);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, GU) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Gu_initWithSMExpr_(SMParser_unary(self));
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IVIC) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Ivic_initWithSMExpr_(SMParser_unary(self));
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, BANG_BANG) } count:1 type:SMTokenType_class_()])) {
    id<JavaUtilList> tokens = new_JavaUtilArrayList_init();
    while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IDENTIFIER) } count:1 type:SMTokenType_class_()])) {
      [tokens addWithId:SMParser_previous(self)];
      SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, DOT) } count:1 type:SMTokenType_class_()]);
    }
    if ([tokens isEmpty]) {
      [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) errorWithSMToken:SMParser_peek(self) withNSString:@"Annotations operator needs params!"];
    }
    return new_SMExpr_Annotations_initWithJavaUtilList_(tokens);
  }
  return SMParser_call(self);
}

SMExpr *SMParser_call(SMParser *self) {
  SMExpr *expr = SMParser_primary(self);
  while (true) {
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, LEFT_PAREN) } count:1 type:SMTokenType_class_()])) {
      expr = SMParser_finishCallWithSMExpr_(self, expr);
    }
    else if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, DOT) } count:1 type:SMTokenType_class_()])) {
      SMToken *dot = SMParser_previous(self);
      SMExpr *name;
      if (((SMToken *) nil_chk(SMParser_peek(self)))->type_ == JreLoadEnum(SMTokenType, NUMBER)) {
        name = new_SMExpr_Variable_initWithSMToken_(SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, NUMBER), @"Expected a number or id after '.'."));
      }
      else if (((SMToken *) nil_chk(SMParser_peek(self)))->type_ == JreLoadEnum(SMTokenType, LEFT_PAREN)) {
        name = SMParser_primary(self);
      }
      else {
        name = new_SMExpr_Variable_initWithSMToken_(SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), @"Expected a number of id after '.'."));
      }
      JavaLangInteger *arity = SMParser_peekParams(self);
      expr = new_SMExpr_Get_initWithSMToken_withSMExpr_withSMExpr_withJavaLangInteger_(dot, expr, name, arity);
    }
    else {
      break;
    }
  }
  return expr;
}

SMExpr *SMParser_finishCallWithSMExpr_(SMParser *self, SMExpr *callee) {
  id<JavaUtilList> arguments = new_JavaUtilArrayList_init();
  if (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, RIGHT_PAREN))) {
    do {
      SMParser_matchSequenceWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IDENTIFIER), JreLoadEnum(SMTokenType, EQUAL) } count:2 type:SMTokenType_class_()]);
      [arguments addWithId:SMParser_expression(self)];
    }
    while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, COMMA) } count:1 type:SMTokenType_class_()]));
  }
  SMToken *paren = SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, RIGHT_PAREN), @"Expect ')' after arguments.");
  return new_SMExpr_Call_initWithSMExpr_withSMToken_withJavaUtilList_(callee, paren, arguments);
}

SMExpr *SMParser_primary(SMParser *self) {
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, FALSE) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Literal_initWithSMSimiValue_(new_SMSimiValue_Number_initWithBoolean_(false));
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, TRUE) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Literal_initWithSMSimiValue_(new_SMSimiValue_Number_initWithBoolean_(true));
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NIL) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Literal_initWithSMSimiValue_(nil);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, PASS) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Literal_initWithSMSimiValue_(new_SMPass_init());
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NATIVE) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Literal_initWithSMSimiValue_(new_SMNative_init());
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NUMBER), JreLoadEnum(SMTokenType, STRING) } count:2 type:SMTokenType_class_()])) {
    return new_SMExpr_Literal_initWithSMSimiValue_(((SMToken *) nil_chk(SMParser_previous(self)))->literal_);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, SUPER) } count:1 type:SMTokenType_class_()])) {
    SMToken *keyword = SMParser_previous(self);
    SMToken *superclass_;
    if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, LEFT_PAREN) } count:1 type:SMTokenType_class_()])) {
      superclass_ = SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), @"Expected superclass name in parentheses!");
      (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, RIGHT_PAREN), @"Expected ')' after superclass specification!");
    }
    else {
      superclass_ = nil;
    }
    (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, DOT), @"Expect '.' after 'super'.");
    SMToken *method = SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, IDENTIFIER), @"Expect superclass method name.");
    JavaLangInteger *arity = SMParser_peekParams(self);
    return new_SMExpr_Super_initWithSMToken_withSMToken_withSMToken_withJavaLangInteger_(keyword, superclass_, method, arity);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, SELF) } count:1 type:SMTokenType_class_()])) {
    SMToken *previous = SMParser_previous(self);
    SMToken *specifier = nil;
    if (SMParser_peekSequenceWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, LEFT_PAREN), JreLoadEnum(SMTokenType, DEF), JreLoadEnum(SMTokenType, RIGHT_PAREN) } count:3 type:SMTokenType_class_()])) {
      specifier = new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, DEF), SMConstants_SELF_DEF, nil, ((SMToken *) nil_chk(previous))->line_);
      (void) SMParser_advance(self);
      (void) SMParser_advance(self);
      (void) SMParser_advance(self);
    }
    return new_SMExpr_Self_initWithSMToken_withSMToken_(new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, SELF), SMConstants_SELF, nil, ((SMToken *) nil_chk(previous))->line_), specifier);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, LEFT_BRACKET), JreLoadEnum(SMTokenType, DOLLAR_LEFT_BRACKET) } count:2 type:SMTokenType_class_()])) {
    return SMParser_objectLiteral(self);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, DEF) } count:1 type:SMTokenType_class_()])) {
    return SMParser_blockWithNSString_withBoolean_(self, SMParser_LAMBDA, true);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, COLON) } count:1 type:SMTokenType_class_()])) {
    SMToken *declaration = new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, DEF), nil, nil, ((SMToken *) nil_chk(SMParser_previous(self)))->line_);
    return new_SMExpr_Block_initWithSMToken_withJavaUtilList_withJavaUtilList_withBoolean_(declaration, new_JavaUtilArrayList_init(), SMParser_getBlockStatementsWithSMToken_withNSString_(self, declaration, SMParser_LAMBDA), true);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IDENTIFIER) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Variable_initWithSMToken_(SMParser_previous(self));
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, LEFT_PAREN) } count:1 type:SMTokenType_class_()])) {
    SMExpr *expr = SMParser_expression(self);
    (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, RIGHT_PAREN), @"Expect ')' after expression.");
    return new_SMExpr_Grouping_initWithSMExpr_(expr);
  }
  if (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, QUESTION) } count:1 type:SMTokenType_class_()])) {
    return new_SMExpr_Unary_initWithSMToken_withSMExpr_(SMParser_previous(self), SMParser_primary(self));
  }
  @throw nil_chk(SMParser_errorWithSMToken_withNSString_(self, SMParser_peek(self), @"Expect expression."));
}

SMExpr *SMParser_objectLiteral(SMParser *self) {
  SMToken *opener = SMParser_previous(self);
  id<JavaUtilList> props = new_JavaUtilArrayList_init();
  jboolean dictionary = true;
  if (!SMParser_checkWithSMTokenType_(self, JreLoadEnum(SMTokenType, RIGHT_BRACKET))) {
    SMParser_matchAllNewlines(self);
    dictionary = (SMParser_peekSequenceWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, IDENTIFIER), JreLoadEnum(SMTokenType, EQUAL) } count:2 type:SMTokenType_class_()]) || SMParser_peekSequenceWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, STRING), JreLoadEnum(SMTokenType, EQUAL) } count:2 type:SMTokenType_class_()]));
    do {
      SMParser_matchAllNewlines(self);
      [props addWithId:dictionary ? SMParser_assignment(self) : SMParser_or__(self)];
      SMParser_matchAllNewlines(self);
    }
    while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, COMMA) } count:1 type:SMTokenType_class_()]));
    SMParser_matchAllNewlines(self);
  }
  (void) SMParser_consumeWithSMTokenType_withNSString_(self, JreLoadEnum(SMTokenType, RIGHT_BRACKET), @"Expect ']' at the end of object.");
  return new_SMExpr_ObjectLiteral_initWithSMToken_withJavaUtilList_withBoolean_(opener, props, dictionary);
}

void SMParser_matchAllNewlines(SMParser *self) {
  while (SMParser_matchWithSMTokenTypeArray_(self, [IOSObjectArray newArrayWithObjects:(id[]){ JreLoadEnum(SMTokenType, NEWLINE) } count:1 type:SMTokenType_class_()])) {
  }
}

jboolean SMParser_matchSequenceWithSMTokenTypeArray_(SMParser *self, IOSObjectArray *types) {
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(types))->size_; i++) {
    jint index = self->current_ + i;
    if (index >= [((id<JavaUtilList>) nil_chk(self->tokens_)) size]) {
      return false;
    }
    if (((SMToken *) nil_chk([self->tokens_ getWithInt:index]))->type_ != IOSObjectArray_Get(types, i)) {
      return false;
    }
  }
  for (jint i = 0; i < types->size_; i++) {
    (void) SMParser_advance(self);
  }
  return true;
}

jboolean SMParser_matchWithSMTokenTypeArray_(SMParser *self, IOSObjectArray *types) {
  {
    IOSObjectArray *a__ = types;
    SMTokenType * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    SMTokenType * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      SMTokenType *type = *b__++;
      if (SMParser_checkWithSMTokenType_(self, type)) {
        (void) SMParser_advance(self);
        return true;
      }
    }
  }
  return false;
}

SMToken *SMParser_consumeWithSMTokenType_withNSString_(SMParser *self, SMTokenType *type, NSString *message) {
  if (SMParser_checkWithSMTokenType_(self, type)) return SMParser_advance(self);
  @throw nil_chk(SMParser_errorWithSMToken_withNSString_(self, SMParser_peek(self), message));
}

jboolean SMParser_checkWithSMTokenType_(SMParser *self, SMTokenType *tokenType) {
  if (SMParser_isAtEnd(self)) return tokenType == JreLoadEnum(SMTokenType, EOF);
  return ((SMToken *) nil_chk(SMParser_peek(self)))->type_ == tokenType;
}

SMToken *SMParser_advance(SMParser *self) {
  if (!SMParser_isAtEnd(self)) self->current_++;
  return SMParser_previous(self);
}

jboolean SMParser_isAtEnd(SMParser *self) {
  return ((SMToken *) nil_chk(SMParser_peek(self)))->type_ == JreLoadEnum(SMTokenType, EOF);
}

SMToken *SMParser_peek(SMParser *self) {
  return [((id<JavaUtilList>) nil_chk(self->tokens_)) getWithInt:self->current_];
}

jboolean SMParser_peekSequenceWithSMTokenTypeArray_(SMParser *self, IOSObjectArray *tokenTypes) {
  if (self->current_ + ((IOSObjectArray *) nil_chk(tokenTypes))->size_ >= [((id<JavaUtilList>) nil_chk(self->tokens_)) size]) {
    return false;
  }
  for (jint i = 0; i < tokenTypes->size_; i++) {
    if (((SMToken *) nil_chk([self->tokens_ getWithInt:self->current_ + i]))->type_ != IOSObjectArray_Get(tokenTypes, i)) {
      return false;
    }
  }
  return true;
}

SMToken *SMParser_previous(SMParser *self) {
  return [((id<JavaUtilList>) nil_chk(self->tokens_)) getWithInt:self->current_ - 1];
}

SMToken *SMParser_operatorFromAssignWithSMToken_(SMParser *self, SMToken *assignOp) {
  SMTokenType *type;
  switch ([((SMToken *) nil_chk(assignOp))->type_ ordinal]) {
    case SMTokenType_Enum_PLUS_EQUAL:
    type = JreLoadEnum(SMTokenType, PLUS);
    break;
    case SMTokenType_Enum_MINUS_EQUAL:
    type = JreLoadEnum(SMTokenType, MINUS);
    break;
    case SMTokenType_Enum_STAR_EQUAL:
    type = JreLoadEnum(SMTokenType, STAR);
    break;
    case SMTokenType_Enum_SLASH_EQUAL:
    type = JreLoadEnum(SMTokenType, SLASH);
    break;
    case SMTokenType_Enum_MOD_EQUAL:
    type = JreLoadEnum(SMTokenType, MOD);
    break;
    default:
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@", @"Unable to process assignment operator: ", assignOp->type_));
  }
  return new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(type, assignOp->lexeme_, nil, assignOp->line_);
}

SMParser_ParseError *SMParser_errorWithSMToken_withNSString_(SMParser *self, SMToken *token, NSString *message) {
  [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) errorWithSMToken:token withNSString:message];
  return new_SMParser_ParseError_init();
}

void SMParser_synchronize(SMParser *self) {
  (void) SMParser_advance(self);
  while (!SMParser_isAtEnd(self)) {
    switch ([((SMToken *) nil_chk(SMParser_peek(self)))->type_ ordinal]) {
      case SMTokenType_Enum_CLASS:
      case SMTokenType_Enum_CLASS_FINAL:
      case SMTokenType_Enum_CLASS_OPEN:
      case SMTokenType_Enum_DEF:
      case SMTokenType_Enum_FOR:
      case SMTokenType_Enum_IF:
      case SMTokenType_Enum_WHILE:
      case SMTokenType_Enum_PRINT:
      case SMTokenType_Enum_RETURN:
      return;
    }
    (void) SMParser_advance(self);
  }
}

id<JavaUtilList> SMParser_getAnnotations(SMParser *self) {
  if ([((id<JavaUtilList>) nil_chk(self->annotations_)) isEmpty]) {
    return nil;
  }
  id<JavaUtilList> copy_ = JavaUtilCollections_unmodifiableListWithJavaUtilList_(new_JavaUtilArrayList_initWithJavaUtilCollection_(self->annotations_));
  [((id<JavaUtilList>) nil_chk(self->annotations_)) clear];
  return copy_;
}

void SMParser_addParamChecksWithSMToken_withJavaUtilList_withJavaUtilList_(SMParser *self, SMToken *declaration, id<JavaUtilList> params, id<JavaUtilList> stmts) {
  for (SMExpr * __strong param in nil_chk(params)) {
    if ([param isKindOfClass:[SMExpr_Binary class]]) {
      SMExpr_Binary *typeCheck = (SMExpr_Binary *) cast_chk(param, [SMExpr_Binary class]);
      SMExpr *paramName = ((SMExpr_Binary *) nil_chk(typeCheck))->left_;
      SMExpr *paramType = typeCheck->right_;
      id<JavaUtilList> exceptionStmt = JavaUtilCollections_singletonListWithId_(new_SMStmt_Expression_initWithSMExpr_(new_SMExpr_Call_initWithSMExpr_withSMToken_withJavaUtilList_(new_SMExpr_Get_initWithSMToken_withSMExpr_withSMExpr_withJavaLangInteger_(declaration, new_SMExpr_Call_initWithSMExpr_withSMToken_withJavaUtilList_(new_SMExpr_Variable_initWithSMToken_(SMToken_namedWithNSString_(SMConstants_EXCEPTION_TYPE_MISMATCH)), declaration, JavaUtilArrays_asListWithNSObjectArray_([IOSObjectArray newArrayWithObjects:(id[]){ paramName, typeCheck->right_ } count:2 type:SMExpr_class_()])), new_SMExpr_Variable_initWithSMToken_(SMToken_namedWithNSString_(SMConstants_RAISE)), JavaLangInteger_valueOfWithInt_(0)), declaration, JavaUtilCollections_emptyList())));
      [((id<JavaUtilList>) nil_chk(stmts)) addWithInt:0 withId:new_SMStmt_If_initWithSMStmt_Elsif_withJavaUtilList_withSMExpr_Block_(new_SMStmt_Elsif_initWithSMExpr_withSMExpr_Block_(new_SMExpr_Binary_initWithSMExpr_withSMToken_withSMExpr_(paramName, new_SMToken_initWithSMTokenType_withNSString_withSMSimiValue_withInt_(JreLoadEnum(SMTokenType, ISNOT), nil, nil, ((SMToken *) nil_chk(declaration))->line_), paramType), new_SMExpr_Block_initWithSMToken_withJavaUtilList_withJavaUtilList_withBoolean_(typeCheck->operator__, JavaUtilCollections_emptyList(), exceptionStmt, true)), JavaUtilCollections_emptyList(), nil)];
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SMParser)

@implementation SMParser_ParseError

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype __nonnull)init {
  SMParser_ParseError_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LSMParser;" };
  static const J2ObjcClassInfo _SMParser_ParseError = { "ParseError", "net.globulus.simi", ptrTable, methods, NULL, 7, 0xa, 1, 0, 0, -1, -1, -1, -1 };
  return &_SMParser_ParseError;
}

@end

void SMParser_ParseError_init(SMParser_ParseError *self) {
  JavaLangRuntimeException_init(self);
}

SMParser_ParseError *new_SMParser_ParseError_init() {
  J2OBJC_NEW_IMPL(SMParser_ParseError, init)
}

SMParser_ParseError *create_SMParser_ParseError_init() {
  J2OBJC_CREATE_IMPL(SMParser_ParseError, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SMParser_ParseError)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: src/Environment.java
//

#include "J2ObjC_source.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "BlockImpl.h"
#include "Environment.h"
#include "Expr.h"
#include "RuntimeError.h"
#include "SimiProperty.h"
#include "SimiValue.h"
#include "SparseArray.h"
#include "Stmt.h"
#include "Token.h"
#include "TokenType.h"

@interface SMEnvironment () {
 @public
  id<JavaUtilMap> props_;
  id<JavaUtilMap> statementBlocks_;
}

- (void)popBlockWithSMStmt_BlockStmt:(id<SMStmt_BlockStmt>)stmt
                     withJavaUtilMap:(id<JavaUtilMap>)yieldedStmts;

@end

J2OBJC_FIELD_SETTER(SMEnvironment, props_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(SMEnvironment, statementBlocks_, id<JavaUtilMap>)

__attribute__((unused)) static void SMEnvironment_popBlockWithSMStmt_BlockStmt_withJavaUtilMap_(SMEnvironment *self, id<SMStmt_BlockStmt> stmt, id<JavaUtilMap> yieldedStmts);

@implementation SMEnvironment

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype __nonnull)init {
  SMEnvironment_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (instancetype __nonnull)initWithSMEnvironment:(SMEnvironment *)enclosing {
  SMEnvironment_initWithSMEnvironment_(self, enclosing);
  return self;
}

- (jboolean)hasWithNSString:(NSString *)key {
  return [((id<JavaUtilMap>) nil_chk(props_)) containsKeyWithId:key];
}

- (SMSimiValue *)getWithSMToken:(SMToken *)name {
  if ([((id<JavaUtilMap>) nil_chk(props_)) containsKeyWithId:((SMToken *) nil_chk(name))->lexeme_]) {
    return [((id<SMSimiProperty>) nil_chk([props_ getWithId:name->lexeme_])) getValue];
  }
  if (enclosing_ != nil) {
    return [enclosing_ getWithSMToken:name];
  }
  return nil;
}

- (void)assignWithSMToken:(SMToken *)name
       withSMSimiProperty:(id<SMSimiProperty>)prop
              withBoolean:(jboolean)allowImmutable {
  NSString *key = ((SMToken *) nil_chk(name))->lexeme_;
  if ([((id<JavaUtilMap>) nil_chk(props_)) containsKeyWithId:key]) {
    if (allowImmutable) {
      (void) [props_ putWithId:key withId:prop];
    }
    else {
      @throw new_SMRuntimeError_initWithSMToken_withNSString_(name, JreStrcat("$$C", @"Cannot assign to a const, use ", [((SMTokenType *) nil_chk(JreLoadEnum(SMTokenType, DOLLAR_EQUAL))) toCode], '!'));
    }
  }
  else {
    [self defineWithNSString:key withSMSimiProperty:prop];
  }
}

- (void)defineWithNSString:(NSString *)name
        withSMSimiProperty:(id<SMSimiProperty>)property {
  if (property == nil || [property getValue] == nil) {
    (void) [((id<JavaUtilMap>) nil_chk(props_)) removeWithId:name];
  }
  else {
    (void) [((id<JavaUtilMap>) nil_chk(props_)) putWithId:name withId:property];
  }
}

- (SMEnvironment *)ancestorWithInt:(jint)distance {
  SMEnvironment *environment = self;
  for (jint i = 0; i < distance; i++) {
    environment = ((SMEnvironment *) nil_chk(environment))->enclosing_;
  }
  return environment;
}

- (id<SMSimiProperty>)getAtWithInt:(jint)distance
                      withNSString:(NSString *)name {
  return [((id<JavaUtilMap>) nil_chk(((SMEnvironment *) nil_chk([self ancestorWithInt:distance]))->props_)) getWithId:name];
}

- (void)assignAtWithInt:(jint)distance
            withSMToken:(SMToken *)name
     withSMSimiProperty:(id<SMSimiProperty>)prop {
  [self assignAtWithInt:distance withSMToken:name withSMSimiProperty:prop withBoolean:false];
}

- (void)assignAtWithInt:(jint)distance
            withSMToken:(SMToken *)name
     withSMSimiProperty:(id<SMSimiProperty>)prop
            withBoolean:(jboolean)allowImmutable {
  [((SMEnvironment *) nil_chk([self ancestorWithInt:distance])) assignWithSMToken:name withSMSimiProperty:prop withBoolean:allowImmutable];
}

- (id<SMSimiProperty>)tryGetWithNSString:(NSString *)name {
  for (SMEnvironment *env = self; env != nil; env = env->enclosing_) {
    id<SMSimiProperty> prop = [((id<JavaUtilMap>) nil_chk(env->props_)) getWithId:name];
    if (prop != nil) {
      return prop;
    }
  }
  return nil;
}

- (NSString *)description {
  NSString *result = [((id<JavaUtilMap>) nil_chk(props_)) description];
  if (enclosing_ != nil) {
    (void) JreStrAppendStrong(&result, "$$", @" -> ", [enclosing_ description]);
  }
  return result;
}

- (NSString *)toStringWithoutValuesOrGlobal {
  if (enclosing_ == nil) {
    return @"Global";
  }
  NSString *result = [((id<JavaUtilSet>) nil_chk([((id<JavaUtilMap>) nil_chk(props_)) keySet])) description];
  if (enclosing_->enclosing_ != nil) {
    (void) JreStrAppendStrong(&result, "$$", @" -> ", [enclosing_ toStringWithoutValuesOrGlobal]);
  }
  return result;
}

- (SMBlockImpl *)getOrAssignBlockWithSMStmt_BlockStmt:(id<SMStmt_BlockStmt>)stmt
                                     withSMExpr_Block:(SMExpr_Block *)declaration
                                      withJavaUtilMap:(id<JavaUtilMap>)yieldedStmts {
  SMBlockImpl *block = [((id<JavaUtilMap>) nil_chk(statementBlocks_)) getWithId:stmt];
  if (block == nil) {
    SMSparseArray *yieldedBlocks = [((id<JavaUtilMap>) nil_chk(yieldedStmts)) getWithId:stmt];
    if (yieldedBlocks != nil) {
      block = [yieldedBlocks getWithInt:depth_];
    }
    if (block == nil) {
      block = new_SMBlockImpl_initWithSMExpr_Block_withSMEnvironment_(declaration, self);
      (void) [statementBlocks_ putWithId:stmt withId:block];
    }
  }
  return block;
}

- (void)endBlockWithSMStmt_BlockStmt:(id<SMStmt_BlockStmt>)stmt
                     withJavaUtilMap:(id<JavaUtilMap>)yieldedStmts {
  (void) [((id<JavaUtilMap>) nil_chk(statementBlocks_)) removeWithId:stmt];
  SMEnvironment_popBlockWithSMStmt_BlockStmt_withJavaUtilMap_(self, stmt, yieldedStmts);
  for (id<SMStmt_BlockStmt> __strong child in nil_chk([((id<SMStmt_BlockStmt>) nil_chk(stmt)) getChildren])) {
    [self endBlockWithSMStmt_BlockStmt:child withJavaUtilMap:yieldedStmts];
  }
}

- (void)popBlockWithSMStmt_BlockStmt:(id<SMStmt_BlockStmt>)stmt
                     withJavaUtilMap:(id<JavaUtilMap>)yieldedStmts {
  SMEnvironment_popBlockWithSMStmt_BlockStmt_withJavaUtilMap_(self, stmt, yieldedStmts);
}

- (SMEnvironment *)deepClone {
  SMEnvironment *clone = new_SMEnvironment_initWithSMEnvironment_(enclosing_);
  for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([((id<JavaUtilMap>) nil_chk(props_)) entrySet])) {
    id<SMSimiProperty> value = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue];
    (void) [clone->props_ putWithId:[entry_ getKey] withId:(value == nil) ? nil : [((id<SMSimiProperty>) nil_chk(value)) cloneWithBoolean:false]];
  }
  return clone;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "LSMSimiValue;", 0x0, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 5, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "LSMEnvironment;", 0x0, 9, 10, -1, -1, -1, -1 },
    { NULL, "LSMSimiProperty;", 0x0, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 13, 15, -1, -1, -1, -1 },
    { NULL, "LSMSimiProperty;", 0x1, 16, 2, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 17, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSMBlockImpl;", 0x0, 18, 19, -1, 20, -1, -1 },
    { NULL, "V", 0x0, 21, 22, -1, 23, -1, -1 },
    { NULL, "V", 0x2, 24, 22, -1, 23, -1, -1 },
    { NULL, "LSMEnvironment;", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithSMEnvironment:);
  methods[2].selector = @selector(hasWithNSString:);
  methods[3].selector = @selector(getWithSMToken:);
  methods[4].selector = @selector(assignWithSMToken:withSMSimiProperty:withBoolean:);
  methods[5].selector = @selector(defineWithNSString:withSMSimiProperty:);
  methods[6].selector = @selector(ancestorWithInt:);
  methods[7].selector = @selector(getAtWithInt:withNSString:);
  methods[8].selector = @selector(assignAtWithInt:withSMToken:withSMSimiProperty:);
  methods[9].selector = @selector(assignAtWithInt:withSMToken:withSMSimiProperty:withBoolean:);
  methods[10].selector = @selector(tryGetWithNSString:);
  methods[11].selector = @selector(description);
  methods[12].selector = @selector(toStringWithoutValuesOrGlobal);
  methods[13].selector = @selector(getOrAssignBlockWithSMStmt_BlockStmt:withSMExpr_Block:withJavaUtilMap:);
  methods[14].selector = @selector(endBlockWithSMStmt_BlockStmt:withJavaUtilMap:);
  methods[15].selector = @selector(popBlockWithSMStmt_BlockStmt:withJavaUtilMap:);
  methods[16].selector = @selector(deepClone);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "enclosing_", "LSMEnvironment;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "props_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x12, -1, -1, 25, -1 },
    { "statementBlocks_", "LJavaUtilMap;", .constantValue.asLong = 0, 0x12, -1, -1, 26, -1 },
    { "depth_", "I", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LSMEnvironment;", "has", "LNSString;", "get", "LSMToken;", "assign", "LSMToken;LSMSimiProperty;Z", "define", "LNSString;LSMSimiProperty;", "ancestor", "I", "getAt", "ILNSString;", "assignAt", "ILSMToken;LSMSimiProperty;", "ILSMToken;LSMSimiProperty;Z", "tryGet", "toString", "getOrAssignBlock", "LSMStmt_BlockStmt;LSMExpr_Block;LJavaUtilMap;", "(LStmt$BlockStmt;LExpr$Block;Ljava/util/Map<LStmt$BlockStmt;LSparseArray<LBlockImpl;>;>;)LBlockImpl;", "endBlock", "LSMStmt_BlockStmt;LJavaUtilMap;", "(LStmt$BlockStmt;Ljava/util/Map<LStmt$BlockStmt;LSparseArray<LBlockImpl;>;>;)V", "popBlock", "Ljava/util/Map<Ljava/lang/String;LSimiProperty;>;", "Ljava/util/Map<LStmt$BlockStmt;LBlockImpl;>;" };
  static const J2ObjcClassInfo _SMEnvironment = { "Environment", "net.globulus.simi", ptrTable, methods, fields, 7, 0x0, 17, 4, -1, -1, -1, -1, -1 };
  return &_SMEnvironment;
}

@end

void SMEnvironment_init(SMEnvironment *self) {
  NSObject_init(self);
  self->props_ = new_JavaUtilHashMap_init();
  self->statementBlocks_ = new_JavaUtilHashMap_init();
  self->enclosing_ = nil;
  self->depth_ = 0;
}

SMEnvironment *new_SMEnvironment_init() {
  J2OBJC_NEW_IMPL(SMEnvironment, init)
}

SMEnvironment *create_SMEnvironment_init() {
  J2OBJC_CREATE_IMPL(SMEnvironment, init)
}

void SMEnvironment_initWithSMEnvironment_(SMEnvironment *self, SMEnvironment *enclosing) {
  NSObject_init(self);
  self->props_ = new_JavaUtilHashMap_init();
  self->statementBlocks_ = new_JavaUtilHashMap_init();
  self->enclosing_ = enclosing;
  self->depth_ = (enclosing != nil) ? (((SMEnvironment *) nil_chk(enclosing))->depth_ + 1) : 0;
}

SMEnvironment *new_SMEnvironment_initWithSMEnvironment_(SMEnvironment *enclosing) {
  J2OBJC_NEW_IMPL(SMEnvironment, initWithSMEnvironment_, enclosing)
}

SMEnvironment *create_SMEnvironment_initWithSMEnvironment_(SMEnvironment *enclosing) {
  J2OBJC_CREATE_IMPL(SMEnvironment, initWithSMEnvironment_, enclosing)
}

void SMEnvironment_popBlockWithSMStmt_BlockStmt_withJavaUtilMap_(SMEnvironment *self, id<SMStmt_BlockStmt> stmt, id<JavaUtilMap> yieldedStmts) {
  SMSparseArray *blocks = [((id<JavaUtilMap>) nil_chk(yieldedStmts)) getWithId:stmt];
  if (blocks != nil) {
    [blocks removeWithInt:self->depth_];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SMEnvironment)

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: src/ActiveSimi.java
//

#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/io/PrintStream.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Runnable.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"
#include "ActiveSimi.h"
#include "Constants.h"
#include "ErrorHub.h"
#include "ErrorWatcher.h"
#include "Interpreter.h"
#include "NativeModulesManager.h"
#include "Parser.h"
#include "Resolver.h"
#include "RuntimeError.h"
#include "Scanner.h"
#include "SimiClassImpl.h"
#include "SimiObject.h"
#include "SimiProperty.h"
#include "SimiValue.h"
#include "Token.h"
#include "TokenType.h"

#pragma clang diagnostic ignored "-Wprotocol"

@interface SMActiveSimi ()

- (instancetype __nonnull)init;

+ (NSString *)readFileWithNSString:(NSString *)path;

+ (void)runWithNSString:(NSString *)source;

+ (id<SMSimiProperty>)runExpressionWithNSString:(NSString *)expression;

+ (id<JavaUtilList>)scanImportsWithJavaUtilList:(id<JavaUtilList>)input
                               withJavaUtilList:(id<JavaUtilList>)imports
                     withSMNativeModulesManager:(SMNativeModulesManager *)nativeModulesManager;

@end

inline SMInterpreter *SMActiveSimi_get_interpreter(void);
inline SMInterpreter *SMActiveSimi_set_interpreter(SMInterpreter *value);
static SMInterpreter *SMActiveSimi_interpreter;
J2OBJC_STATIC_FIELD_OBJ(SMActiveSimi, interpreter, SMInterpreter *)

inline id<SMActiveSimi_ImportResolver> SMActiveSimi_get_importResolver(void);
inline id<SMActiveSimi_ImportResolver> SMActiveSimi_set_importResolver(id<SMActiveSimi_ImportResolver> value);
static id<SMActiveSimi_ImportResolver> SMActiveSimi_importResolver;
J2OBJC_STATIC_FIELD_OBJ(SMActiveSimi, importResolver, id<SMActiveSimi_ImportResolver>)

inline id<SMErrorWatcher> SMActiveSimi_get_WATCHER(void);
static id<SMErrorWatcher> SMActiveSimi_WATCHER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(SMActiveSimi, WATCHER, id<SMErrorWatcher>)

__attribute__((unused)) static void SMActiveSimi_init(SMActiveSimi *self);

__attribute__((unused)) static SMActiveSimi *new_SMActiveSimi_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static SMActiveSimi *create_SMActiveSimi_init(void);

__attribute__((unused)) static NSString *SMActiveSimi_readFileWithNSString_(NSString *path);

__attribute__((unused)) static void SMActiveSimi_runWithNSString_(NSString *source);

__attribute__((unused)) static id<SMSimiProperty> SMActiveSimi_runExpressionWithNSString_(NSString *expression);

__attribute__((unused)) static id<JavaUtilList> SMActiveSimi_scanImportsWithJavaUtilList_withJavaUtilList_withSMNativeModulesManager_(id<JavaUtilList> input, id<JavaUtilList> imports, SMNativeModulesManager *nativeModulesManager);

@interface SMActiveSimi_1 : NSObject < SMErrorWatcher >

- (instancetype __nonnull)init;

- (void)reportWithInt:(jint)line
         withNSString:(NSString *)where
         withNSString:(NSString *)message;

- (void)runtimeErrorWithSMRuntimeError:(SMRuntimeError *)error;

@end

J2OBJC_EMPTY_STATIC_INIT(SMActiveSimi_1)

__attribute__((unused)) static void SMActiveSimi_1_init(SMActiveSimi_1 *self);

__attribute__((unused)) static SMActiveSimi_1 *new_SMActiveSimi_1_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static SMActiveSimi_1 *create_SMActiveSimi_1_init(void);

@interface SMActiveSimi_ImportResolver : NSObject

@end

@interface SMActiveSimi_Callback : NSObject

@end

@interface SMActiveSimi_$Lambda$1 : NSObject < JavaLangRunnable > {
 @public
  id<SMActiveSimi_Callback> val$callback_;
  NSString *val$className_;
  NSString *val$methodName_;
  IOSObjectArray *val$params_;
}

- (void)run;

@end

J2OBJC_EMPTY_STATIC_INIT(SMActiveSimi_$Lambda$1)

__attribute__((unused)) static void SMActiveSimi_$Lambda$1_initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(SMActiveSimi_$Lambda$1 *self, id<SMActiveSimi_Callback> capture$0, NSString *capture$1, NSString *capture$2, IOSObjectArray *capture$3);

__attribute__((unused)) static SMActiveSimi_$Lambda$1 *new_SMActiveSimi_$Lambda$1_initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(id<SMActiveSimi_Callback> capture$0, NSString *capture$1, NSString *capture$2, IOSObjectArray *capture$3) NS_RETURNS_RETAINED;

__attribute__((unused)) static SMActiveSimi_$Lambda$1 *create_SMActiveSimi_$Lambda$1_initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(id<SMActiveSimi_Callback> capture$0, NSString *capture$1, NSString *capture$2, IOSObjectArray *capture$3);

J2OBJC_INITIALIZED_DEFN(SMActiveSimi)

jboolean SMActiveSimi_hadError = false;
jboolean SMActiveSimi_hadRuntimeError = false;

@implementation SMActiveSimi

+ (jboolean)hadError {
  return SMActiveSimi_hadError;
}

+ (void)setHadError:(jboolean)value {
  SMActiveSimi_hadError = value;
}

+ (jboolean)hadRuntimeError {
  return SMActiveSimi_hadRuntimeError;
}

+ (void)setHadRuntimeError:(jboolean)value {
  SMActiveSimi_hadRuntimeError = value;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype __nonnull)init {
  SMActiveSimi_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (void)load__WithNSStringArray:(IOSObjectArray *)files {
  SMActiveSimi_load__WithNSStringArray_(files);
}

+ (id<SMSimiProperty>)evalWithNSString:(NSString *)className_
                          withNSString:(NSString *)methodName
               withSMSimiPropertyArray:(IOSObjectArray *)params {
  return SMActiveSimi_evalWithNSString_withNSString_withSMSimiPropertyArray_(className_, methodName, params);
}

+ (void)evalAsyncWithSMActiveSimi_Callback:(id<SMActiveSimi_Callback>)callback
                              withNSString:(NSString *)className_
                              withNSString:(NSString *)methodName
                   withSMSimiPropertyArray:(IOSObjectArray *)params {
  SMActiveSimi_evalAsyncWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(callback, className_, methodName, params);
}

+ (void)setImportResolverWithSMActiveSimi_ImportResolver:(id<SMActiveSimi_ImportResolver>)ir {
  SMActiveSimi_setImportResolverWithSMActiveSimi_ImportResolver_(ir);
}

+ (NSString *)readFileWithNSString:(NSString *)path {
  return SMActiveSimi_readFileWithNSString_(path);
}

+ (void)runWithNSString:(NSString *)source {
  SMActiveSimi_runWithNSString_(source);
}

+ (id<SMSimiProperty>)runExpressionWithNSString:(NSString *)expression {
  return SMActiveSimi_runExpressionWithNSString_(expression);
}

+ (id<JavaUtilList>)scanImportsWithJavaUtilList:(id<JavaUtilList>)input
                               withJavaUtilList:(id<JavaUtilList>)imports
                     withSMNativeModulesManager:(SMNativeModulesManager *)nativeModulesManager {
  return SMActiveSimi_scanImportsWithJavaUtilList_withJavaUtilList_withSMNativeModulesManager_(input, imports, nativeModulesManager);
}

+ (SMSimiClassImpl *)getObjectClass {
  return SMActiveSimi_getObjectClass();
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x89, 0, 1, 2, -1, -1, -1 },
    { NULL, "LSMSimiProperty;", 0x89, 3, 4, -1, -1, -1, -1 },
    { NULL, "V", 0x89, 5, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 7, 8, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xa, 9, 10, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 11, 10, 2, -1, -1, -1 },
    { NULL, "LSMSimiProperty;", 0xa, 12, 10, -1, -1, -1, -1 },
    { NULL, "LJavaUtilList;", 0xa, 13, 14, 2, 15, -1, -1 },
    { NULL, "LSMSimiClassImpl;", 0x8, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(load__WithNSStringArray:);
  methods[2].selector = @selector(evalWithNSString:withNSString:withSMSimiPropertyArray:);
  methods[3].selector = @selector(evalAsyncWithSMActiveSimi_Callback:withNSString:withNSString:withSMSimiPropertyArray:);
  methods[4].selector = @selector(setImportResolverWithSMActiveSimi_ImportResolver:);
  methods[5].selector = @selector(readFileWithNSString:);
  methods[6].selector = @selector(runWithNSString:);
  methods[7].selector = @selector(runExpressionWithNSString:);
  methods[8].selector = @selector(scanImportsWithJavaUtilList:withJavaUtilList:withSMNativeModulesManager:);
  methods[9].selector = @selector(getObjectClass);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "interpreter", "LSMInterpreter;", .constantValue.asLong = 0, 0xa, -1, 16, -1, -1 },
    { "hadError", "Z", .constantValue.asLong = 0, 0x8, -1, 17, -1, -1 },
    { "hadRuntimeError", "Z", .constantValue.asLong = 0, 0x8, -1, 18, -1, -1 },
    { "importResolver", "LSMActiveSimi_ImportResolver;", .constantValue.asLong = 0, 0xa, -1, 19, -1, -1 },
    { "WATCHER", "LSMErrorWatcher;", .constantValue.asLong = 0, 0x1a, -1, 20, -1, -1 },
  };
  static const void *ptrTable[] = { "load", "[LNSString;", "LJavaIoIOException;", "eval", "LNSString;LNSString;[LSMSimiProperty;", "evalAsync", "LSMActiveSimi_Callback;LNSString;LNSString;[LSMSimiProperty;", "setImportResolver", "LSMActiveSimi_ImportResolver;", "readFile", "LNSString;", "run", "runExpression", "scanImports", "LJavaUtilList;LJavaUtilList;LSMNativeModulesManager;", "(Ljava/util/List<LToken;>;Ljava/util/List<Ljava/lang/String;>;LNativeModulesManager;)Ljava/util/List<LToken;>;", &SMActiveSimi_interpreter, &SMActiveSimi_hadError, &SMActiveSimi_hadRuntimeError, &SMActiveSimi_importResolver, &SMActiveSimi_WATCHER, "LSMActiveSimi_ImportResolver;LSMActiveSimi_Callback;" };
  static const J2ObjcClassInfo _SMActiveSimi = { "ActiveSimi", "net.globulus.simi", ptrTable, methods, fields, 7, 0x1, 10, 5, -1, 21, -1, -1, -1 };
  return &_SMActiveSimi;
}

+ (void)initialize {
  if (self == [SMActiveSimi class]) {
    SMActiveSimi_WATCHER = new_SMActiveSimi_1_init();
    J2OBJC_SET_INITIALIZED(SMActiveSimi)
  }
}

@end

void SMActiveSimi_init(SMActiveSimi *self) {
  NSObject_init(self);
}

SMActiveSimi *new_SMActiveSimi_init() {
  J2OBJC_NEW_IMPL(SMActiveSimi, init)
}

SMActiveSimi *create_SMActiveSimi_init() {
  J2OBJC_CREATE_IMPL(SMActiveSimi, init)
}

void SMActiveSimi_load__WithNSStringArray_(IOSObjectArray *files) {
  SMActiveSimi_initialize();
  [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) removeWatcherWithSMErrorWatcher:SMActiveSimi_WATCHER];
  [((SMErrorHub *) nil_chk(SMErrorHub_sharedInstance())) addWatcherWithSMErrorWatcher:SMActiveSimi_WATCHER];
  JavaLangStringBuilder *source = new_JavaLangStringBuilder_initWithNSString_(@"import \"stdlib/Stdlib.simi\"\n\n");
  {
    IOSObjectArray *a__ = files;
    NSString * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    NSString * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      NSString *file = *b__++;
      (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([source appendWithNSString:@"import \""])) appendWithNSString:file])) appendWithNSString:@"\"\n"];
    }
  }
  SMActiveSimi_runWithNSString_([source description]);
}

id<SMSimiProperty> SMActiveSimi_evalWithNSString_withNSString_withSMSimiPropertyArray_(NSString *className_, NSString *methodName, IOSObjectArray *params) {
  SMActiveSimi_initialize();
  if (SMActiveSimi_interpreter == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Must call load() before using eval!");
  }
  JavaLangStringBuilder *sb = new_JavaLangStringBuilder_init();
  if (className_ != nil) {
    (void) [((JavaLangStringBuilder *) nil_chk([sb appendWithNSString:className_])) appendWithChar:'.'];
  }
  (void) [((JavaLangStringBuilder *) nil_chk([sb appendWithNSString:methodName])) appendWithChar:'('];
  id<JavaUtilList> names = [((SMInterpreter *) nil_chk(SMActiveSimi_interpreter)) defineTempVarsWithSMSimiPropertyArray:params];
  jboolean first = true;
  for (NSString * __strong name in nil_chk(names)) {
    if (first) {
      first = false;
    }
    else {
      (void) [sb appendWithNSString:@", "];
    }
    (void) [sb appendWithNSString:name];
  }
  (void) [sb appendWithChar:')'];
  id<SMSimiProperty> result = SMActiveSimi_runExpressionWithNSString_([sb description]);
  [((SMInterpreter *) nil_chk(SMActiveSimi_interpreter)) undefineTempVarsWithJavaUtilList:names];
  return result;
}

void SMActiveSimi_evalAsyncWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(id<SMActiveSimi_Callback> callback, NSString *className_, NSString *methodName, IOSObjectArray *params) {
  SMActiveSimi_initialize();
  @synchronized(SMActiveSimi_interpreter) {
    [new_JavaLangThread_initWithJavaLangRunnable_(new_SMActiveSimi_$Lambda$1_initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(callback, className_, methodName, params)) run];
  }
}

void SMActiveSimi_setImportResolverWithSMActiveSimi_ImportResolver_(id<SMActiveSimi_ImportResolver> ir) {
  SMActiveSimi_initialize();
  SMActiveSimi_importResolver = ir;
}

NSString *SMActiveSimi_readFileWithNSString_(NSString *path) {
  SMActiveSimi_initialize();
  if (SMActiveSimi_importResolver == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"ImportResolver not initialized!");
  }
  return [SMActiveSimi_importResolver readFileWithNSString:path];
}

void SMActiveSimi_runWithNSString_(NSString *source) {
  SMActiveSimi_initialize();
  SMNativeModulesManager *nativeModulesManager = new_SMNativeModulesManager_init();
  id<JavaUtilList> imports = new_JavaUtilArrayList_init();
  jlong time = JavaLangSystem_currentTimeMillis();
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printWithNSString:@"Scanning and resolving imports..."];
  SMScanner *scanner = new_SMScanner_initWithNSString_(source);
  id<JavaUtilList> tokens = SMActiveSimi_scanImportsWithJavaUtilList_withJavaUtilList_withSMNativeModulesManager_([scanner scanTokensWithBoolean:true], imports, nativeModulesManager);
  [JreLoadStatic(JavaLangSystem, out) printlnWithNSString:JreStrcat("CJ$", ' ', (JavaLangSystem_currentTimeMillis() - time), @" ms")];
  time = JavaLangSystem_currentTimeMillis();
  [JreLoadStatic(JavaLangSystem, out) printWithNSString:@"Parsing..."];
  SMParser *parser = new_SMParser_initWithJavaUtilList_(tokens);
  id<JavaUtilList> statements = [parser parse];
  if (SMActiveSimi_hadError) return;
  SMActiveSimi_interpreter = new_SMInterpreter_initWithSMNativeModulesManager_(nativeModulesManager);
  SMResolver *resolver = new_SMResolver_initWithSMInterpreter_(SMActiveSimi_interpreter);
  [resolver resolveWithJavaUtilList:statements];
  [JreLoadStatic(JavaLangSystem, out) printlnWithNSString:JreStrcat("CJ$", ' ', (JavaLangSystem_currentTimeMillis() - time), @" ms")];
  time = JavaLangSystem_currentTimeMillis();
  if (SMActiveSimi_hadError) return;
  (void) [((SMInterpreter *) nil_chk(SMActiveSimi_interpreter)) interpretWithJavaUtilList:statements];
  [JreLoadStatic(JavaLangSystem, out) printlnWithNSString:JreStrcat("$J$", @"Interpreting... ", (JavaLangSystem_currentTimeMillis() - time), @" ms")];
}

id<SMSimiProperty> SMActiveSimi_runExpressionWithNSString_(NSString *expression) {
  SMActiveSimi_initialize();
  id<JavaUtilList> tokens = [new_SMScanner_initWithNSString_(expression) scanTokensWithBoolean:true];
  id<JavaUtilList> statements = [new_SMParser_initWithJavaUtilList_(tokens) parse];
  return [((SMInterpreter *) nil_chk(SMActiveSimi_interpreter)) interpretWithJavaUtilList:statements];
}

id<JavaUtilList> SMActiveSimi_scanImportsWithJavaUtilList_withJavaUtilList_withSMNativeModulesManager_(id<JavaUtilList> input, id<JavaUtilList> imports, SMNativeModulesManager *nativeModulesManager) {
  SMActiveSimi_initialize();
  id<JavaUtilList> result = new_JavaUtilArrayList_init();
  jint len = [((id<JavaUtilList>) nil_chk(input)) size];
  for (jint i = 0; i < len; i++) {
    SMToken *token = [input getWithInt:i];
    if (((SMToken *) nil_chk(token))->type_ != JreLoadEnum(SMTokenType, IMPORT)) {
      continue;
    }
    i++;
    SMToken *nextToken = [input getWithInt:i];
    if (((SMToken *) nil_chk(nextToken))->type_ != JreLoadEnum(SMTokenType, STRING)) {
      continue;
    }
    NSString *location = [((SMSimiValue *) nil_chk(nextToken->literal_)) getString];
    if ([((id<JavaUtilList>) nil_chk(imports)) containsWithId:location]) {
      continue;
    }
    if ([((NSString *) nil_chk(location)) java_hasSuffix:@".simi"]) {
      id<JavaUtilList> tokens = [new_SMScanner_initWithNSString_(SMActiveSimi_readFileWithNSString_(location)) scanTokensWithBoolean:false];
      [result addAllWithJavaUtilCollection:SMActiveSimi_scanImportsWithJavaUtilList_withJavaUtilList_withSMNativeModulesManager_(tokens, imports, nativeModulesManager)];
    }
  }
  [result addAllWithJavaUtilCollection:input];
  return result;
}

SMSimiClassImpl *SMActiveSimi_getObjectClass() {
  SMActiveSimi_initialize();
  if (SMActiveSimi_interpreter == nil) {
    return nil;
  }
  return (SMSimiClassImpl *) cast_chk([((SMSimiValue *) nil_chk([((id<SMSimiProperty>) nil_chk([SMActiveSimi_interpreter getGlobalWithNSString:SMConstants_CLASS_OBJECT])) getValue])) getObject], [SMSimiClassImpl class]);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SMActiveSimi)

@implementation SMActiveSimi_1

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype __nonnull)init {
  SMActiveSimi_1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)reportWithInt:(jint)line
         withNSString:(NSString *)where
         withNSString:(NSString *)message {
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$I$$$$", @"[line ", line, @"] Error", where, @": ", message)];
  *JreLoadStaticRef(SMActiveSimi, hadError) = true;
}

- (void)runtimeErrorWithSMRuntimeError:(SMRuntimeError *)error {
  [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$$IC", [((SMRuntimeError *) nil_chk(error)) getMessage], @"\n[line ", ((SMToken *) nil_chk(error->token_))->line_, ']')];
  *JreLoadStaticRef(SMActiveSimi, hadRuntimeError) = true;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(reportWithInt:withNSString:withNSString:);
  methods[2].selector = @selector(runtimeErrorWithSMRuntimeError:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "report", "ILNSString;LNSString;", "runtimeError", "LSMRuntimeError;", "LSMActiveSimi;" };
  static const J2ObjcClassInfo _SMActiveSimi_1 = { "", "net.globulus.simi", ptrTable, methods, NULL, 7, 0x8018, 3, 0, 4, -1, -1, -1, -1 };
  return &_SMActiveSimi_1;
}

@end

void SMActiveSimi_1_init(SMActiveSimi_1 *self) {
  NSObject_init(self);
}

SMActiveSimi_1 *new_SMActiveSimi_1_init() {
  J2OBJC_NEW_IMPL(SMActiveSimi_1, init)
}

SMActiveSimi_1 *create_SMActiveSimi_1_init() {
  J2OBJC_CREATE_IMPL(SMActiveSimi_1, init)
}

@implementation SMActiveSimi_ImportResolver

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNSString;", 0x401, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(readFileWithNSString:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "readFile", "LNSString;", "LSMActiveSimi;" };
  static const J2ObjcClassInfo _SMActiveSimi_ImportResolver = { "ImportResolver", "net.globulus.simi", ptrTable, methods, NULL, 7, 0x609, 1, 0, 2, -1, -1, -1, -1 };
  return &_SMActiveSimi_ImportResolver;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(SMActiveSimi_ImportResolver)

@implementation SMActiveSimi_Callback

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x401, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(doneWithSMSimiProperty:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "done", "LSMSimiProperty;", "LSMActiveSimi;" };
  static const J2ObjcClassInfo _SMActiveSimi_Callback = { "Callback", "net.globulus.simi", ptrTable, methods, NULL, 7, 0x609, 1, 0, 2, -1, -1, -1, -1 };
  return &_SMActiveSimi_Callback;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(SMActiveSimi_Callback)

@implementation SMActiveSimi_$Lambda$1

- (void)run {
  [((id<SMActiveSimi_Callback>) nil_chk(val$callback_)) doneWithSMSimiProperty:SMActiveSimi_evalWithNSString_withNSString_withSMSimiPropertyArray_(val$className_, val$methodName_, val$params_)];
}

@end

void SMActiveSimi_$Lambda$1_initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(SMActiveSimi_$Lambda$1 *self, id<SMActiveSimi_Callback> capture$0, NSString *capture$1, NSString *capture$2, IOSObjectArray *capture$3) {
  self->val$callback_ = capture$0;
  self->val$className_ = capture$1;
  self->val$methodName_ = capture$2;
  self->val$params_ = capture$3;
  NSObject_init(self);
}

SMActiveSimi_$Lambda$1 *new_SMActiveSimi_$Lambda$1_initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(id<SMActiveSimi_Callback> capture$0, NSString *capture$1, NSString *capture$2, IOSObjectArray *capture$3) {
  J2OBJC_NEW_IMPL(SMActiveSimi_$Lambda$1, initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_, capture$0, capture$1, capture$2, capture$3)
}

SMActiveSimi_$Lambda$1 *create_SMActiveSimi_$Lambda$1_initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_(id<SMActiveSimi_Callback> capture$0, NSString *capture$1, NSString *capture$2, IOSObjectArray *capture$3) {
  J2OBJC_CREATE_IMPL(SMActiveSimi_$Lambda$1, initWithSMActiveSimi_Callback_withNSString_withNSString_withSMSimiPropertyArray_, capture$0, capture$1, capture$2, capture$3)
}
